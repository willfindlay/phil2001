<html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>LogiCola Help</title></head>
<body bgcolor=#BBFFFF leftmargin="20" rightmargin="20" topmargin="20" link=#000077 vlink=#007700 alink=#770000><A name="0"><font face="Segoe UI,Arial,Helvetica">
<center title="These give an introduction to LogiCola">
<A HREF="#1">Quick Start</A> - <A HREF="#2">Teachers</A> - <A HREF="#3">Web Sites</A> - <A HREF="#4">Techie Details</A> - <A HREF="#5">Symbols</A></center><br>
<center title="These give information about exercise sets">
Exercises: <A HREF="#A">A</A> <A HREF="#B">B</A> <A HREF="#C">C</A> <A HREF="#D">D</A> <A HREF="#E">E</A> <A HREF="#F">F</A> <A HREF="#G">G</A> <A HREF="#H">H</A> <A HREF="#I">I</A> <A HREF="#J">J</A> <A HREF="#K">K</A> <A HREF="#L">L</A> <A HREF="#M">M</A> <A HREF="#N">N</A> <A HREF="#O">O</A> <A HREF="#P">P</A> <A HREF="#Q">Q</A> <A HREF="#R">R</A></center>

<div align="justify"><HR noshade size=2><center>

<font size="6">LogiCola Help</font></center><br>

<b>LogiCola</b> is a program to help you learn logic. LogiCola generates homework problems, gives feedback on answers, and records your progress. LogiCola can run on Windows, Macintosh, or Linux -- and goes with Harry J. Gensler's <i>Introduction to Logic</i> (Routledge Press, third edition 2017). LogiCola (including this help file) is copyrighted &copy; 2008+ by Harry J. Gensler.<p>

This help file begins with a <A HREF="#1">quick start</A> to using LogiCola, <A HREF="#2">suggestions for teachers</A>,
<A HREF="#3">related Web sites</A>, <A HREF="#4">techie details</A>, and <A HREF="#5">logic symbols that you can use in your writing</A>. Then it sketches points of logic that connect with LogiCola exercise sets (A to R) and various book chapters:<br><br>

<center>
<table border="4" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Syllogistic: <A HREF="#A">A - Translations</A> <A HREF="#B">B - Arguments</A>&nbsp;&nbsp;</center></td>
<td nowrap><center>Chapter 2</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Propositional: <A HREF="#C">C - Translations</A> <A HREF="#D">D - Truth Tables</A>&nbsp;&nbsp;<br>&nbsp;&nbsp;<A HREF="#E">E - Arguments</A> <A HREF="#F">F - Inference Rules</A> <A HREF="#G">G - Proofs</A>&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;Chapters 6 & 7&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Quantificational: <A HREF="#H">H - Translations</A> <A HREF="#I">I - Proofs</A>&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;Chapters 8 & 9&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Modal: <A HREF="#J">J - Translations</A> <A HREF="#K">K - Proofs</A>&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;Chapters 10 & 11&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Deontic: <A HREF="#L">L - Translations</A> <A HREF="#M">M - Proofs</A>&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;Chapter 12&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Belief: <A HREF="#N">N - Translations</A> <A HREF="#O">O - Proofs</A>&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;Chapter 13&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;<A HREF="#P">P - Probability</A> <A HREF="#Q">Q - Definitions</A> <A HREF="#R">R - Fallacies</A>&nbsp;&nbsp;</center></td>
<td nowrap align=center>&nbsp;&nbsp;Chapters 5 & 3 & 4&nbsp;&nbsp;</tr>
</table></center>

<br><A name="1"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Quick Start</font><br><br>
<font size="5">Starting LogiCola</font></center><br>

<img src="lc.gif" alt="LogiCola cola-can icon" vspace=10 hspace=10 border=0 height=36 width=36 align=left>You start LogiCola by clicking the cola-can icon; depending on how you installed LogiCola, this icon may be on your desktop, start menu, start screen, or flash drive. The first time you use LogiCola, it asks about your name, place, sound effects, scoring level, and onscreen keyboard:
<ul>
<li>NAME: Since scores record under your name, use your real last name and always keep your first and last name the same.
<li>PLACE: The place you give (e.g., "Michigan") will sometimes be used in exercises.
<li>SOUND EFFECTS: These are entertaining but may disturb others if you have them too loud.
<li>SCORING LEVEL: You pick 9 to 1 (hardest to easiest) or 0 (off). I suggest 9.
<li>ONSCREEN KEYBOARD: While this is intended for touchscreens, you can also use it with a mouse. You can do LogiCola using only touch, or using mouse and keyboard. With a tablet, try portrait mode (high and skinny).
</ul>

You can use the OPTIONS menu to change your choices later.<br><br>

<center><font size="5">Exercises and Scoring</font></center><br>
Let's say you want to do exercise A (EM), which is set A with options E and M:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>Exercise A (EM)&nbsp;&nbsp;=&nbsp;&nbsp;AEM&nbsp;&nbsp;=&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Set A (Syllogistic translations): Easier + Multiple choice&nbsp;&nbsp;</center></td></tr>
</table></center><br>

Use LOAD NEW EXERCISE SET under the FILE menu to load set A. Then under the FILE menu click the options you want (E and M) until these are checked. Click the mouse or hit a key to get a problem. Problems have instructions on the bottom of the screen:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td  border="0" nowrap>
&nbsp;&nbsp;"All wolverines are ferocious"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translates into syllogistic logic as:<br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1}&nbsp;&nbsp;all W is F<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{2}&nbsp;&nbsp;W is F<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{3}&nbsp;&nbsp;w is F<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{4}&nbsp;&nbsp;all F is W<br><br>
&nbsp;&nbsp;What is your answer, Harry? _<br><br>
&nbsp;&nbsp;TO ANSWER: Click the answer, type its number,&nbsp;&nbsp;<br>
&nbsp;&nbsp;or highlight it (using spacebar or arrow keys)&nbsp;&nbsp;<br>
&nbsp;&nbsp;and hit ENTER.</td>
<td nowrap><center>
On a<br>&nbsp;&nbsp;touchscreen,&nbsp;&nbsp;<br>slide your<br>finger on<br>the screen<br>to highlight<br>your choice,<br>and then<br>release.
</center></td>
</tr></table></center><br>

You get feedback and suggestions about your answers. If you have scoring turned on, your point total increases with right answers and decreases with wrong answers. When you reach 100 points, LogiCola records that you completed the exercise at such and such a level. If you still feel unsure about the exercise, you can do it again as many times as you like; since the problems are randomly constructed, you'll likely get different problems each time you do an exercise. Or you might want to bring up another exercise (using the FILE menu) or quit the program.<br><br>
LogiCola uses a "no fault" scoring system: it only records when you complete an exercise. The scoring level doesn't influence how hard the problems are, but only how many points you lose for wrong answers; it's much harder to complete an exercise at level 9 than at level 1. If you do an exercise more than once, you get credit for the highest level at which you complete it.<br><br>

<center><font size="5">Menu Commands</font></center><br>
These four items always display on the left side of LogiCola's menu bar:
<ul>
<li>FILE: Use the file menu to change the exercise set (from A to R) or exercise options (for example, between multiple-choice and type-the-answer), print out a problem on a sheet of paper (so you can bring it to your teacher if you have a question), capture the screen (so you can paste the problem into a word processor, graphics program, or e-mail), or exit the program.
<li>OPTIONS: Use the options menu to change your name, place, scoring level, screen color, font, sound effects, help balloons, onscreen keyboard, and so on.
<li>TOOLS: Use the tools menu to view your scores (and print them or send them by e-mail), copy the scores or program to a flash drive, or update the program.
<li>HELP: Use the help menu to read this help file, view supplementary materials (like class slides or the teacher manual), read the latest news about LogiCola or the book, and view the "about box" (which tells what version of LogiCola you are using and gives related Web links).
</ul>
These items sometimes display on the right side of LogiCola's menu bar:
<blockquote>
<img src="ii.gif" border=0>INFO: Display logic rules.<br>
<img src="ig.gif" border=0>GETANS: Have LogiCola get you the next answer.<br>
<img src="id.gif" border=0>DOPROB: Have LogiCola finish the whole problem for you.<br>
<img src="ir.gif" border=0>REPEAT: Do the previous problem again with scoring disabled.
</blockquote>
You can use ALT + the first letter to execute these commands; so ALT+G has LogiCola get you the next answer. (In Macintosh, you use the &#8984; command key instead of ALT.) You also can access the menu commands by right-clicking the LogiCola window.<br>

<br><A name="2"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Suggestions for Teachers</font></center><br>

I assign LogiCola for homework to supplement classroom activity. If you do this, you'll want to tell your students to
<a href="http://www.harryhiker.com/lc/">install LogiCola from the Web</a> to a flash drive or computer and to read the beginning of LogiCola's help file (what you're reading now) up to, but not including, the "Set A - Syllogistic Translations" section. You'll want to assign specific exercises; you can use the LogiSkor program (which you install from the previous link and whose <a href="http://www.harryhiker.com/lc/docs/skorhelp.htm">help file is here</a>) to record and process their scores. At exam time, most of my students send me their scores by e-mail (using the PASTE TO E-MAIL button that you get using LogiCola's TOOLS | VIEW SCORES option); but a few bring their USB flash drives to the test, where I process scores using the classroom computer or my laptop.<p>

Teachers who assign LogiCola need to be familiar with LogiCola and its help file (or at least the first part), the beginning of the <A HREF="http://www.harryhiker.com/manual.pdf">teacher manual</a> (especially the "Using the LogiCola Software" section), the LogiSkor program and its help file, and the syllabi for my <A HREF="http://www.harryhiker.com/courses.htm#L">basic</A> and <A HREF="http://www.harryhiker.com/courses.htm#S">intermediate</A> logic courses (which give an example of how to use the book and software).<p>

Students find LogiCola an easy program to use and a fun way to learn logic. It's a very effective learning tool; as I note in the teacher manual, it has improved student performance considerably (about 8 percent, or a little over a grade, on comparable written exams). Doing homework on LogiCola is much better than doing homework on paper (besides the fact that you don't have to correct it!), as we can see from this comparison:<p>

<center><table border="0" bordercolor=#000000 bgcolor=#BBFFFF width=90%>
<tr><td><center><b>Homework on paper</b></center></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><center><b>Homework on LogiCola</b></center></td></tr>
<tr><td><div align="justify">Paper won't talk back to your students. It won't tell them if they're doing the problems right or wrong. It won't give suggestions. And it won't work out examples, even if students need this to get started.</div></td><td> &nbsp;&emsp;&nbsp;&emsp;&nbsp; </td><td><div align="justify">LogiCola will talk back to your students. It'll tell them immediately if they're doing the problems right or wrong. It'll give suggestions. And it'll work out examples, if students need this to get started.</div></td></tr>
<tr><td><div align="justify">Students all get the same problems. So they can pass around their papers and share the answers.</div></td><td> &nbsp;&emsp;&nbsp;&emsp;&nbsp; </td><td><div align="justify">LogiCola gives every student different problems. So they will share only hints on how to do the problems.</div></td></tr>
<tr><td><div align="justify">Students get the corrected paper back, at best, a couple of days after doing the problems. Only then do they find out what they were doing wrong.</div></td><td> &nbsp;&emsp;&nbsp;&emsp;&nbsp; </td><td><div align="justify">LogiCola's immediate response motivates students and makes learning more fun, like playing a video game. Homework needn't be boring.</div></td></tr></table></center><br>

LogiCola can be used for things other than homework. I often use LogiCola in my office, when I work with students individually, as a random-problem generator &ndash; for example, to generate an argument that the student will then prove on my blackboard. And I sometimes use LogiCola to help generate problems to put on a test.<br>

<br><A name="3"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Related Web Sites</font></center><br>

To update LogiCola (in case automatic updating doesn't work), go to the <a href="http://www.harryhiker.com/lc/">Download LogiCola</a> page and reinstall the program; this won't erase your scores. The "About Box" (under LogiCola's HELP | ABOUT LOGICOLA option) lists alternative download sites. If none of these work, try a <a href="http://www.google.com/search?q=%22Download+LogiCola%22">"Download LogiCola" Google search</a>.<p>

Here is a <a href="http://www.harryhiker.com/logic.htm">logic pre-test</a> useful in your first week of studying logic.<p>

Here are syllabi for my <A HREF="http://www.harryhiker.com/courses.htm#L">basic</A> and <A HREF="http://www.harryhiker.com/courses.htm#S">intermediate</A> logic courses that use my logic book and software.<p>

Here are <a href="http://www.harryhiker.com/lc/index.htm#S">some supplementary materials</a>; you can access most of the same materials more directly from LogiCola itself, by clicking the HELP menu and then picking SUPPLEMENTARY MATERIALS.<p>

Here is <a href="http://www.harryhiker.com">my home page</a>. Check out my <a href="http://www.harryhiker.com/photos.htm">hiking pictures and movies</a>.<br>

<br><A name="4"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Techie Details</font></center><br>

When run on Windows, the "LogiCola.exe" file contains the whole program. LogiCola.exe produces various other files and puts these into an "LC" folder (and the ABOUT box will tell you where this folder is). The "LC" folder can have various items, but most importantly:<ul>
<li>"Score.lc" has your scores.
<li>"LC.ini" remembers your preferences about name, sound effects, font, and so forth.
<li>"LC\Docs" is a subfolder for supplementary materials (like the teacher manual), if you used HELP | SUPPLEMENTARY MATERIALS to download these. It also holds the Help.htm file and supporting .gif graphic files. LogiCola will still work if you erase the LC\Docs folder and all its files.
</ul>Alongside "LogiCola.exe" you may find the "LogiSkor.exe" score processing program for teachers (if you installed it) or a "autorun.inf" file on your flash drive (if you chose to customize your flash drive with a Logicola title and icon).<p>

LogiCola can also run on <a href="http://www.harryhiker.com/lc/mac.htm" target="_blank">Macintosh</a>  or <a href="http://www.harryhiker.com/lc/linux.htm" target="_blank">Linux</a>.<p>

Let me sketch LogiCola's history.<p>

In 1987, when hardly anyone used computers, I created LogiCola to go with my two Prentice-Hall logic books (<i>Logic: Analyzing and Appraising Arguments</i> and <i>Symbolic Logic: Classical and Advanced Systems</i>). I programmed LogiCola in John Starkweather's <a href="http://en.wikipedia.org/wiki/PILOT">PILOT</a>, a simple instructional language with twenty basic commands. LogiCola ran in DOS on IBM PCs from two 5&#0189;-inch floppy disks &ndash; which contained various .PLT text files and a 21-KB PILOT.EXE interpreter. LogiCola looked like this:<p>

<center><img src="l1.gif" border=0></center><br>

In 1990, I used <a href="http://en.wikipedia.org/wiki/Turbo_Pascal">Borland's Turbo Pascal</a> to create a more powerful LC.EXE file to run the .PLT exercise sets. LogiCola now had drop-down menus and could use a mouse.<p>

In 1992, I made Macintosh and then Windows versions (even though back then very few used Windows).<p>

In 2003, I made a much improved Windows version (with better proof exercises, better sound effects, and some use of the Internet) to go with the first edition of my Routledge logic textbook. But the Mac version stagnated and could run only on older Macs.<p>

In 2008, I massively re-wrote LogiCola in 32-bit Pascal (Borland Delphi 7 without VCL); it used 20,000 lines of code, half in Pascal and half in my own version of PILOT. The program now is 32-bit (so it can run on 64-bit Windows) and oriented to flash drives and hard disks (not floppy disks). Other changes involve fonts, workspace, and setup/update.<p>

In 2011, I made LogiCola more Mac friendly and able to run as a self-contained Mac application (using an internal Wine simulator).<p>

In 2013, I added a new "training wheels" feature to the proofs exercises and I made LogiCola more touch friendly to run better on Windows tablets and touchscreens.<p>

In 2016, I added exercises for Copi Proofs and Truth Trees.<br>

<br><A name="5"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>

<center><font size="6">Logic Symbols</font></center><br>

Here are some symbols that you can use in your writing (e.g., a Word document or e-mail):<p>

<center>&nbsp; &there4; &nbsp; &sim; &nbsp; &#8226; &nbsp; &or; &nbsp; &sup; &nbsp; &equiv; &nbsp; &exist; &nbsp; &#9674; &nbsp; &#9744; &nbsp; <p> &nbsp; &#8658; &nbsp; &#8656; &nbsp; &#0185; &nbsp; &#0186; &nbsp; &ne; &nbsp; &#9484; &nbsp; &#9474; &nbsp; &#9492; &nbsp; </center><p>

Highlight the symbol you want to use, click copy, go to Word or your e-mail program or whatever, and click paste. After you paste the symbol, you may have to reset font and font-size to match the rest of your writing. This is quick-and-dirty, but it works so long as your computer is fairly recent and uses Unicode fonts.<br>

<br><A name="A"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=4>

<center><font size="2">LogiCola Exercise Sets: A to R</font></center><HR noshade size=4>
<center><font size="6">Set A - Syllogistic Translations</font><br><br>
<font size="5">Easier Translations</font></center><br>

<b>Syllogistic logic</b> studies arguments whose validity depends on "all," "no," "some," and similar notions. In symbolizing such arguments, we use capital letters for general categories (like "logician") and small letters for specific individuals (like "Gensler"). We also use these five words: "all," "no," "some," "is," and "not." These vocabulary items can combine to form "wffs," or grammatical sequences. A <b>wff (well-formed formula)</b> is a sequence having any of these eight forms (where other capital letters and other small letters may be used instead):<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;all A is B&nbsp;&nbsp;<br>&nbsp;&nbsp;no A is B&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;some A is B&nbsp;&nbsp;<br>&nbsp;&nbsp;some A is not B&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;x is A&nbsp;&nbsp;<br>&nbsp;&nbsp;x is not A&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;x is y&nbsp;&nbsp;<br>&nbsp;&nbsp;x is not y&nbsp;&nbsp;</center></td></tr>
</table></center><br>

Be careful about whether you use a small or a capital letter. Sometimes the rules about wffs tell us which to use. If a formula begins with "all," for example, then we have to use capital letters after it; so "all A is B" is a wff, but "all a is b" is not. But sometimes we have to look at the meaning of the term to determine whether to use a small or a capital letter:
<ul>
<li>Use capital letters for general terms (terms that describe or put in a category) &ndash; like "a
cute baby" or "charming" or "drives a Buick."
<li>Use small letters for singular terms (terms that pick out a specific person or thing) &ndash; like
"the world's cutest baby" or "this child" or "David."
</ul>
Here are examples of correct translations:
<ul>
<li>All babies are cute&nbsp;&nbsp;=&nbsp;&nbsp;all B is C
<li>Will Gensler is a baby&nbsp;&nbsp;=&nbsp;&nbsp;w is B
<li>Will Gensler is the world's cutest baby&nbsp;&nbsp;=&nbsp;&nbsp;w is b
</ul>

<center><font size="5">Harder Translations</font></center><br>

English has various idiomatic ways to express our wffs. So instead of "all" we can say "any," "each," "every," or "whoever." Here are some other ways to express our wffs:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;all A is B&nbsp;&nbsp;=&nbsp;&nbsp;<br><br>&nbsp;&nbsp;A's are B's&nbsp;&nbsp;<br>&nbsp;&nbsp;Those who are A are B&nbsp;&nbsp;<br>&nbsp;&nbsp;If a person is A, then she is B&nbsp;&nbsp;<br>&nbsp;&nbsp;If you're A, then you're B&nbsp;&nbsp;<br>&nbsp;&nbsp;Only B's are A's&nbsp;&nbsp;<br>&nbsp;&nbsp;None but B's are A's&nbsp;&nbsp;<br>&nbsp;&nbsp;No one is A unless she is B&nbsp;&nbsp;<br>&nbsp;&nbsp;Nothing is A unless it's B&nbsp;&nbsp;<br>&nbsp;&nbsp;A thing isn't A unless it's B&nbsp;&nbsp;<br>&nbsp;&nbsp;It's false that some A is not B&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;no A is B&nbsp;&nbsp;=&nbsp;&nbsp;no B is A&nbsp;&nbsp;=&nbsp;&nbsp;<br><br>&nbsp;&nbsp;A's aren't B's&nbsp;&nbsp;<br>&nbsp;&nbsp;Every (each, any) A is non-B&nbsp;&nbsp;<br>&nbsp;&nbsp;Whoever (whatever) is A isn't B&nbsp;&nbsp;<br>&nbsp;&nbsp;Those who are A aren't B&nbsp;&nbsp;<br>&nbsp;&nbsp;If a person is A, then she isn't B&nbsp;&nbsp;<br>&nbsp;&nbsp;If you're A, then you aren't B&nbsp;&nbsp;<br>&nbsp;&nbsp;There isn't a single A that's B&nbsp;&nbsp;<br>&nbsp;&nbsp;Not any A is B&nbsp;&nbsp;<br>&nbsp;&nbsp;It's false that there's an A that's B&nbsp;&nbsp;<br>&nbsp;&nbsp;It's false that some A is B.&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;some A is B&nbsp;&nbsp;=&nbsp;&nbsp;some B is A&nbsp;&nbsp;=&nbsp;&nbsp;<br><br>One or more A's are B's&nbsp;&nbsp;<br>&nbsp;&nbsp;A's are sometimes B's&nbsp;&nbsp;<br>&nbsp;&nbsp;It's false that no A is B&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;some A is not B&nbsp;&nbsp;=&nbsp;&nbsp;<br><br>&nbsp;&nbsp;One or more A's aren't B's&nbsp;&nbsp;<br>&nbsp;&nbsp;Not all A's are B's&nbsp;&nbsp;<br>&nbsp;&nbsp;It's false that all A is B&nbsp;&nbsp;</center></td></tr>
</table></center><br>

Here are examples of correct translations:
<ul>
<li>Snakes aren't furry&nbsp;&nbsp;=&nbsp;&nbsp;no S is F
<li>Only men are football players&nbsp;&nbsp;=&nbsp;&nbsp;all F is M
<li>Not all steaks are well done&nbsp;&nbsp;=&nbsp;&nbsp;some S is not W
</ul>
When you translate from English to logic, be careful to use correct wffs.<br>

<br><A name="B"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set B - Syllogistic Arguments</font><br><br>
<font size="5">The Star Test</font></center><br>

A <b>syllogism</b> is a vertical sequence of one or more wffs in which each letter occurs twice and the letters "form a chain" (each wff has at least one letter in common with the wff just below it, if there is one, and the first wff has at least one letter in common with the last wff). The last wff in a syllogism is the <b>conclusion</b>. The other wffs (if any) are <b>premises</b>. Here are two examples of syllogisms:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no P is B&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some C is B&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; some C is not P&nbsp;&nbsp;</td><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a is F&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a is G&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; some F is G&nbsp;&nbsp;</td></tr></table></center><br>

An instance of a letter is <b>distributed</b> in a wff if it occurs just after "all" or anywhere after "no" or "not." The distributed letters here are underlined:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;all <u>A</u> is B&nbsp;&nbsp;<br>&nbsp;&nbsp;no <u>A</u> is <u>B</u>&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;some A is B&nbsp;&nbsp;<br>&nbsp;&nbsp;some A is not <u>B</u>&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;x is A&nbsp;&nbsp;<br>&nbsp;&nbsp;x is not <u>A</u>&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;x is y&nbsp;&nbsp;<br>&nbsp;&nbsp;x is not <u>y</u>&nbsp;&nbsp;</center></td></tr>
</table></center><br>

The star test for syllogisms has two steps:
<ol>
<li>Star premise letters that are distributed and conclusion letters that aren't distributed.
<li>Then the syllogism is VALID if and only if every capital letter is starred <b>exactly</b> once and there is <b>exactly</b> one star on the right-hand side.
</ol>
The first few times, you might want to underline all the distributed letters &ndash; and then star premise letters that are underlined and conclusion letters that aren't underlined. Here are three examples:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no <u>P</u>* is <u>B</u>*&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some C is B&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; some C* is not <u>P</u>&nbsp;&nbsp;</td><td nowrap>
<center>Valid &ndash; every capital<br>
&nbsp;&nbsp;starred once and one&nbsp;&nbsp;<br>
right-hand star.</center></td></tr>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no <u>P</u>* is <u>B</u>*&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some C is not <u>B</u>*&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; some C* is P*&nbsp;&nbsp;</td><td nowrap>
<center>Invalid &ndash; P and B<br>
&nbsp;&nbsp;starred twice and three&nbsp;&nbsp;<br>
right-hand stars.</td></tr>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a is F&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a is G&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; some F* is G*&nbsp;&nbsp;</td><td nowrap>
<center>Valid &ndash; since small<br>
letters can be starred<br>
any number of times.</td></tr>
</table></center><br>

<center><font size="5">English Arguments</font></center><br>

You test an English syllogism by first translating it into symbols (using the same letter for the same idea and different letters for different ideas) &ndash; and then testing the symbolic argument using the star test:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No pure water is burnable.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Some Cuyahoga River<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; water is burnable.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; Some Cuyahoga River<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; water is not pure water.&nbsp;&nbsp;</td><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no <u>P</u>* is <u>B</u>*&nbsp;&nbsp;Valid&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some C is B&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; some C* is not <u>P</u>&nbsp;&nbsp;</td></tr></table></center><br>

When you do an English argument, first try to give an intuitive appraisal of whether the argument is valid or invalid; then work it out in symbols and see whether this gives the same result. If your intuition clashes with the test, then you made a mistake on one or the other; think about the problem further and try to catch what you did wrong. Using this two-prong attack on arguments trains your logical intuitions and gives you a double-check on the results.<br><br>

<center><font size="5">Deriving Conclusions</font></center><br>

To derive a syllogistically valid conclusion from premises, use either intuition (checking your result with the star test) or these rules:<ol>
<li>Translate the premises into logic and star the distributed letters. If rules are broken, then nothing validly follows and you can stop.
<li>The two letters occurring just once in the premises will occur in the conclusion.
<li><b>If both conclusion letters are capitals:</b> if all the premises are universal (have "all" or "no"), then use the "all A is B" or "no A is B" form in the conclusion; otherwise, use "some A is B" or "some A is not B."<br>
<b>If just one conclusion letter is small:</b> use the "x is A" or "x is not A" form in the conclusion.<br>
<b>If both conclusion letters are small:</b> use the "x is y" or "x is not y" form in the conclusion.<br>
<b>Use the negative form ("no" or "not") if there's a negative premise.</b>
<li>Formulate the conclusion and test using the star test. If the argument is invalid, try switching the order of the letters.</ol>

Suppose that you want to derive a conclusion from these premises:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some A is B&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all B is C&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; ??
</td></tr>
</table></center><br>

First you star the premises and see that no rules are broken:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some A is B&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all B* is C&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; ??
</td></tr>
</table></center><br>

The conclusion will have "A" and "C" &ndash; two capital letters. And the conclusion will have "some" &ndash; since you have a "some" in the premises. Also, it will be positive (have "some ... is ..." instead of "some ... is not ...") &ndash; since the premises don't have "no" or "not." So you try "some A is C" in the conclusion:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some A is B&nbsp;&nbsp;Valid&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all B* is C&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; some A* is C*&nbsp;&nbsp;
</td></tr>
</table></center><br>

This works out as VALID. If it didn't come out valid, we'd try switching the letters in the conclusion to see if that would give us a valid argument.<br><br>
The exercises in the book and on the computer use English premises &ndash; and require that you derive a conclusion in English (not in wffs) that follows validly from and uses all the premises. Sometimes no such conclusion follows.<br><br>

<center><font size="5">Venn Diagrams (Circles)</font></center><br>

Venn diagrams give another way to test traditional syllogisms (two-premise syllogisms with no small letters). First we draw three overlapping circles, labeling each with one of the syllogism's letters:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><img src="v1.gif" border=0></td></tr>
</table></center><br>

Visualize circle A containing all A-things, circle B containing all B-things, and circle C containing all C-things. Within the circles are seven distinct areas:
<ul>
<li>The central area, where all three circles overlap, contains whatever has all three features (A and B and C).
<li>Three middle areas contain whatever has only two features (for example, A and B but not C).
<li>Three outer areas contain whatever has only one feature (for example, A but not B or C).
</ul>
Each of the seven areas can be either empty or non-empty. We shade the areas that we know to be empty. We put an "x" in the areas that we know to contain at least one entity. An area without either shading or an "x" is unspecified; it could be either empty or non-empty. After we've drawn our three overlapping circles, we diagram the premises following the directions below. The syllogism is VALID if and only if drawing the premises <i>necessitates</i> drawing the conclusion.<br><br>
We first draw "no" and "all" premises, by shading areas; then we draw "some" premises, by putting an "x" in some area that isn't already shaded. Here is how we draw the statements:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;&nbsp;"no A is B"&nbsp;&nbsp;<br><br>
&nbsp;&nbsp;Shade wherever&nbsp;&nbsp;<br>
&nbsp;&nbsp;A and B overlap.&nbsp;&nbsp;</center></td><td nowrap>
<img src="v2.gif" border=0></td></tr>
<tr><td nowrap><center>
&nbsp;&nbsp;"some A is B"&nbsp;&nbsp;<br><br>
&nbsp;&nbsp;"x" an unshaded area&nbsp;&nbsp;<br>
&nbsp;&nbsp;where A and B overlap.&nbsp;&nbsp;</center></td><td nowrap>
<img src="v4.gif" border=0></td></tr>
</table></center><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;&nbsp;"all A is B"&nbsp;&nbsp;<br><br>
&nbsp;&nbsp;Shade areas of A&nbsp;&nbsp;<br>
&nbsp;&nbsp;that aren't in B.&nbsp;&nbsp;</center></td><td nowrap>
<img src="v3.gif" border=0></td></tr>
<tr><td nowrap><center>
&nbsp;&nbsp;"some A is not B"&nbsp;&nbsp;<br><br>
&nbsp;&nbsp;"x" an unshaded area&nbsp;&nbsp;<br>
&nbsp;&nbsp;in A that isn't in B.&nbsp;&nbsp;</center></td><td nowrap>
<img src="v5.gif" border=0></td></tr>
</table></center><br>

In some cases, consistent with the above directions, we could put the "x" in either of two distinct areas. When this happens, the argument will be invalid; to show this, put the "x" in an area that doesn't draw the conclusion.<br><br>

Consider this example:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no P is B&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some C is B&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; some C is not P&nbsp;&nbsp;<br><br>
<center>Valid</center></td><td nowrap>
<img src="v6.gif" border=0></td></tr></table></center><br>

Here we'd first draw "no P is B," by shading the areas where circles P and B overlap. Then we'd draw "some C is B" by putting an "x" in the only unshaded area where circles C and B overlap. Once we do this, we've automatically drawn the conclusion &ndash; since we've put an "x" in a part of C that is outside P. So the argument is valid &ndash; since drawing the premises automatically draws the conclusion.<br><br>

<center><font size="5">Idiomatic Arguments</font></center><br>

When people argue in contorted ways, we have to reformulate their reasoning more clearly before we can test for validity. When you deal with such idiomatic arguments, first pick out the conclusion (what is being argued for &ndash; often indicated by words like "hence," "thus," "so," "therefore," "must," or "can't") and the premises (what is being argued from &ndash; often indicated by words like "since," "for," and "because"). Translate the premises and conclusion into logic. If some letters occur only once, you may need to add unstated but implicit premises; using the "principle of charity," interpret unclear reasoning in the way that gives the best argument. Finally, test for validity.<br><br>
Here's an idiomatic argument:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;Whatever is good in itself ought to be desired. But&nbsp;&nbsp;<br>
&nbsp;&nbsp;whatever ought to be desired is capable of being&nbsp;&nbsp;<br>
&nbsp;&nbsp;desired. So only pleasure is good in itself, since&nbsp;&nbsp;<br>
&nbsp;&nbsp;only pleasure is capable of being desired.&nbsp;&nbsp;</td></tr></table></center><br>

Here the conclusion is "Only pleasure is good in itself" &ndash; which goes into logic as "all G is P" ("All that is good in itself is pleasure"). If we formulate the rest of the argument and then apply the star test, we see that the argument is valid:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all G* is O&nbsp;&nbsp;Valid&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all O* is C&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all C* is P&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; all G is P*&nbsp;&nbsp;</td></tr></table></center><br>

<A name="C"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set C - Propositional Translations</font><br><br>
<font size="5">Easier Translations</font></center><br>

<b>Propositional logic</b> studies arguments whose validity depends on "if-then," "and," "or," "not," and similar notions. In symbolizing such arguments, we use capital letters for true-or-false statements and parentheses for grouping. We also use five special symbols: "&sim;" (squiggle), "&#8226;" (dot), "&or;" (vee), "&sup;" (horseshoe), and "&equiv;" (threebar):<br><br>

<center>
<table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;&sim;A<br>
&nbsp;&nbsp;(A &#8226; B)<br>
&nbsp;&nbsp;(A &or; B)<br>
&nbsp;&nbsp;(A &sup; B)<br>
&nbsp;&nbsp;(A &equiv; B)</div></td><td nowrap>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Not A&nbsp;&nbsp;<br>
Both A and B&nbsp;&nbsp;<br>
Either A or B&nbsp;&nbsp;<br>
If A then B&nbsp;&nbsp;<br>
A if and only if B&nbsp;&nbsp;</td></tr></table>
</center><br>

A grammatically correct formula is called a <b>wff</b>, or <b>well-formed formula</b>. Wffs are sequences that we can construct using these rules:<br>
<ol>
<li>Any capital letter is a wff.
<li>The result of prefixing any wff with "&sim;" is a wff.
<li>The result of joining any two wffs by "&#8226;" or "&or;" or "&sup;" or "&equiv;" and enclosing the result in parentheses is a wff.
</ol>
For example, "&sim;A&nbsp;&#8226;&nbsp;B" isn't a wff because it lacks parentheses; it's ambiguous between these two forms:<br><br>

<center>(&sim;A&nbsp;&#8226;&nbsp;B)&nbsp;&nbsp;=&nbsp;&nbsp;"Both not-A and B" &ndash; which says that A is false but B is true<br>
&sim;(A&nbsp;&#8226;&nbsp;B)&nbsp;&nbsp;=&nbsp;&nbsp;"Not both A and B" &ndash; which says that at least one is false</center><br>

When translating from English into propositional logic, put "(" wherever you see "both," "either," or "if":<br><br>

<center>
<table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;Either not A or B<br>
&nbsp;&nbsp;Not either A or B</div></td><td nowrap>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
(&sim;A &or; B)&nbsp;&nbsp;<br>
&sim;(A &or; B)&nbsp;&nbsp;</td></tr></table>
</center><br>

Also, group together parts on either side of a comma:<br><br>

<center>
<table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;If A, then B and C<br>
&nbsp;&nbsp;If A then B, and C</div></td><td nowrap>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
(A &sup; (B &#8226; C))&nbsp;&nbsp;<br>
((A &sup; B) &#8226; C)&nbsp;&nbsp;</td></tr></table>
</center><br>

<center><font size="5">Harder Translations</font></center><br>

English has various idiomatic ways to express our wffs. Here are some simple translation rules:
<ul>
<li>Translate "but" ("yet," "however," "although") as "and."
<li>Translate "unless" as "or."
<li>Translate "just if" and "iff" as "if and only if."
</ul>
Most conditional words work the same way. The part after "if" ("provided that," "assuming that," and so on) is the antecedent (the "if"-part, the part before the horseshoe). Here are two examples:<br><br>

<center>
<table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;A if B<br>
&nbsp;&nbsp;Provided that A, B</div></td><td nowrap>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
(B &sup; A)&nbsp;&nbsp;<br>
(A &sup; B)&nbsp;&nbsp;</td></tr></table>
</center><br>

"Only if" has its own rule. The part after "only if" is the consequent (the "then"-part, the part after the horseshoe). Equivalently, write "&sup;" for "only if" (and the next thing will come after the horseshoe). Here are two examples:<br><br>

<center>
<table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;A only if B<br>
&nbsp;&nbsp;Only if A, B</div></td><td nowrap>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
(A &sup; B)&nbsp;&nbsp;<br>
(B &sup; A)&nbsp;&nbsp;</td></tr></table>
</center><br>

Here are three further common forms:<br><br>

<center>
<table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;A is sufficient for B<br>
&nbsp;&nbsp;A is necessary for B<br>
&nbsp;&nbsp;A is necessary and sufficient for B</div></td><td nowrap>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;<br>
&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
(A &sup; B)&nbsp;&nbsp;<br>
(&sim;A &sup; &sim;B)&nbsp;&nbsp;<br>
(A &equiv; B)&nbsp;&nbsp;</td></tr></table>
</center>

<br><A name="D"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set D - Truth Tables</font><br><br>
<font size="5">Basic Truth Tables</font></center><br>

A <b>truth table</b> gives a logical diagram for a wff. It lists all possible truth-value combinations for the letters and says whether the wff is true or false in each case. The truth table for AND is on the left side:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;P&nbsp;&nbsp;Q&nbsp;&nbsp;&nbsp;&nbsp;(P &#8226; Q)&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;<br>
0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;<br>
1&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;<br>
1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;</center></td><td nowrap><center>
AND<br>
&nbsp;&nbsp;(0 &#8226; 0)&nbsp;&nbsp;=&nbsp;&nbsp;0&nbsp;&nbsp;<br>
(0 &#8226; 1)&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
(1 &#8226; 0)&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
(1 &#8226; 1)&nbsp;&nbsp;=&nbsp;&nbsp;1</td></tr>
</table></center><br>

The rows on the extreme left represent possible cases. In the first case, P and Q are both false; then "P&nbsp;and&nbsp;Q" is false. In the second case, P is false and Q is true; here too "P&nbsp;and&nbsp;Q" is false. The third case is similar. Only in the fourth case, where P and Q are both true, is "P&nbsp;and&nbsp;Q" true.<br><br>
"(P&nbsp;&#8226;&nbsp;Q)" claims that both parts are true. The truth equivalences on the right express the same idea. Here "(0&nbsp;&#8226;&nbsp;0)&nbsp;=&nbsp;0" says that an AND statement is false if both parts are false. Likewise, "(1&nbsp;&#8226;&nbsp;1)&nbsp;=&nbsp;1" says that an AND statement is true if both parts are true.<br><br>

Here are the truth table and truth equivalences for OR, IF-THEN, IF-AND-ONLY-IF, and NOT:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;P&nbsp;&nbsp;Q&nbsp;&nbsp;&nbsp;&nbsp;(P &or; Q)&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp; <br>
0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; <br>
1&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; <br>
1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; </center></td><td nowrap><center>
OR<br>
&nbsp;&nbsp;(0 &or; 0)&nbsp;&nbsp;=&nbsp;&nbsp;0&nbsp;&nbsp;<br>
(0 &or; 1)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
(1 &or; 0)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
(1 &or; 1)&nbsp;&nbsp;=&nbsp;&nbsp;1</td></tr>
</table></center><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;P&nbsp;&nbsp;Q&nbsp;&nbsp;&nbsp;&nbsp;(P &sup; Q)&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; <br>
0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; <br>
1&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp; <br>
1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; </center></td><td nowrap><center>
IF-THEN<br>
&nbsp;&nbsp;(0 &sup; 0)&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
(0 &sup; 1)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
(1 &sup; 0)&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
(1 &sup; 1)&nbsp;&nbsp;=&nbsp;&nbsp;1</td></tr>
</table></center><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;P&nbsp;&nbsp;Q&nbsp;&nbsp;&nbsp;&nbsp;(P &equiv; Q)&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; <br>
0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp; <br>
1&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp; <br>
1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; </center></td><td nowrap><center>
&nbsp;&nbsp;IF-AND-ONLY-IF&nbsp;&nbsp;<br>
(0 &equiv; 0)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
(0 &equiv; 1)&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
(1 &equiv; 0)&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
(1 &equiv; 1)&nbsp;&nbsp;=&nbsp;&nbsp;1</td></tr>
</table></center><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;&nbsp;&sim;P&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;<br>
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;</center></td><td nowrap><center>
NOT<br>
&nbsp;&nbsp;&sim;0&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&sim;1&nbsp;&nbsp;=&nbsp;&nbsp;0</td></tr>
</table></center><br>

Learn these truth equivalences thoroughly. Most of them are easy:
<ul>
<li>AND says <i>both</i> parts are true.
<li>OR says <i>at least one</i> part is true.
<li>IF-THEN says we don't have <i>first part true & second part false</i>.
<li>IF-AND-ONLY-IF says both parts have the <i>same</i> truth value.
<li>NOT <i>reverses</i> the truth value.
</ul>
IF-THEN is difficult; these three slogans might help you to remember its truth equivalences:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
Falsity implies anything<br>
Anything implies truth<br>
&nbsp;&nbsp;Truth doesn't imply falsity&nbsp;&nbsp;</center></td><td nowrap><center>
&nbsp;&nbsp;(0&nbsp;&sup;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
(&nbsp;&nbsp;&nbsp;&sup;&nbsp;1)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
(1&nbsp;&sup;&nbsp;0)&nbsp;&nbsp;=&nbsp;&nbsp;0</td></tr>
</table></center><br>

<center><font size="5">Truth Evaluations</font></center><br>

To calculate whether a complex wff is true or false, first substitute "1" and "0" for the letters; then simplify from the inside out, using our truth equivalences, until you get "1" or "0."<br><br>
Suppose that you're given that A=1, B=1, and X=0 (A and B are true while X is false). You want to calculate the truth value of this wff:<br><br>
<center>((A &sup; B) &equiv; &sim;X)</center><br>
First substitute "1" and "0" for the letters:<br><br>
<center>((1 &sup; 1) &equiv; &sim;0)</center><br>
Then substitute equivalents until you get "1" or "0":<br><br>
<center>((1 &sup; 1) &equiv; &sim;0)<br>
(1 &equiv; 1)<br>
1</center><br>
So our formula was true under the specified truth conditions.<br><br>
Simplify parts inside parentheses first. With a wff of the form "&sim;(...)," first work out the part inside parentheses to get 1 or 0; then apply "&sim;" to the result. For example, simplify "&sim;(0 &or; 1)" as follows:<br><br>
<center>&sim;(0 &or; 1)<br>
&sim;1<br>
0</center><br>
Don't try to "distribute" the not; this would give you "(&sim;0&nbsp;&or;&nbsp;&sim;1)" in the second line, and then "(1&nbsp;&or;&nbsp;0)" and "1" &ndash; which is the wrong answer.<br><br>

<center><font size="5">Unknown Evaluations</font></center><br>

Suppose that you're given that T=1, F=0, and U=? (T is true, F is false, and U is unknown). You have to calculate the truth value of this wff:<br><br>
<center>(T &or; U)</center><br>
First you substitute "1," "0," or "?":<br><br>
<center>(1 &or; ?)</center><br>
You may just see that this is true &ndash; since an OR statement is true if at least one part is true. Or you can try the "?" both ways &ndash; as "1" and as "0":<br><br>
<center>(1 &or; 1) = 1<br>
(1 &or; 0) = 1</center><br>
Since it comes out true both ways, the formula is true.<br><br>

<center><font size="5">Formula Truth Tables</font></center><br>

We also can do truth tables for complex formulas. A formula with n distinct letters has 2<sup>n</sup> possible truth combinations. So with 1 letter you get 2 combinations, with 2 letters you get 4 combinations, and with 3 letters you get 8 combinations:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;A&nbsp;&nbsp;</u>&nbsp;<br>
0<br>
1</center></td><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;A&nbsp;&nbsp;B&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;0<br>
0&nbsp;&nbsp;1<br>
1&nbsp;&nbsp;0<br>
1&nbsp;&nbsp;1</center></td><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;A&nbsp;&nbsp;B&nbsp;&nbsp;C&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;0<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;1<br>
0&nbsp;&nbsp;1&nbsp;&nbsp;0<br>
0&nbsp;&nbsp;1&nbsp;&nbsp;1<br>
1&nbsp;&nbsp;0&nbsp;&nbsp;0<br>
1&nbsp;&nbsp;0&nbsp;&nbsp;1<br>
1&nbsp;&nbsp;1&nbsp;&nbsp;0<br>
1&nbsp;&nbsp;1&nbsp;&nbsp;1</center></td></table></center><br>

To do a truth table, write the formula on the right and the individual letters in the formula on the left (writing each letter just once). Under the individual letters, write all the possible truth combinations. Under the formula, write whether the formula would be true or false under each combination. As an example, here's the truth table for "((P&nbsp;&or;&nbsp;Q)&nbsp;&sup;&nbsp;R)":<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;P&nbsp;&nbsp;Q&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;((P &or; Q) &sup; Q)&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
0&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
1&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
1&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</center></td></table></center><br>

For each row, you have to figure out whether the larger formula is true or false under the truth combination given; this can involve much calculating for complicated formulas.<br><br>

<center><font size="5">Argument Truth Tables</font></center><br>

We can use a truth table to test the validity of a propositional argument. First construct a truth table showing the truth value of the premises and conclusion for all possible cases. The argument is VALID if and only if no possible case has premises all true and conclusion false. Suppose we want to test whether this argument is valid:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It's in my left hand or my right hand.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It's not in my right hand.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; It's in my left hand.&nbsp;&nbsp;</td><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (L &or; R)&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &sim;R&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; L&nbsp;&nbsp;</td></tr></table></center><br>

We do a truth table for the premises and conclusion; the argument is valid, since no row has premises all true and conclusion false (we never get "110"):<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;L&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;(L &or; R), &sim;R&nbsp;&nbsp;&there4;&nbsp;&nbsp;L&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
1&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</center></td></tr>
</table></center><br>

By contrast, this argument is invalid:<br><br>

<center><table border="2" rules=all rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;<u>&nbsp;&nbsp;A&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;(A &sup; B), B&nbsp;&nbsp;&there4;&nbsp;&nbsp;A&nbsp;&nbsp;</u>&nbsp;<br>
0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
1&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</center></td><td nowrap>
<br><br>&#8656; Invalid (we get "110")&nbsp;&nbsp;<br><br><br>
</td></tr>
</table></center>

<br><A name="E"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set E - Propositional Arguments</font><br><br>
<font size="5">The Truth-Assignment Test</font></center><br>

Set each premise to 1 and the conclusion to 0. Figure out the truth value of as many letters as possible. The argument is VALID if and only if no possible way to assign 1 and 0 to the letters will keep the premises all 1 and conclusion 0. Here's an example:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(L&#0186; &or; R&#0186;)&nbsp;&nbsp;&ne;&nbsp;&nbsp;1&nbsp;&nbsp;Valid&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&sim;R&#0186;&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&there4;&nbsp;L&#0186;&nbsp;&nbsp;=&nbsp;&nbsp;0</td></tr>
</table></center><br>

We first set premises = 1 and conclusion = 0, just to see if this is possible. It isn't &ndash; since then R would have to be 0 (since &sim;R&nbsp;&nbsp;=&nbsp;&nbsp;1), L would have to be 0 (since L&nbsp;&nbsp;=&nbsp;&nbsp;0), and the first premise would be (0&nbsp;&or;&nbsp;0), or 0, so we have to cross out the "=." So we can't make premises all true and conclusion false. So the argument is valid.<br><br>
Here's a trickier example:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&sim;(A &#8226; B&#0185;)&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4;&nbsp;&sim;B&#0185;&nbsp;&nbsp;=&nbsp;&nbsp;0</td></tr>
</table></center><br>

We first set premises =&nbsp;&nbsp;1 and conclusion =&nbsp;&nbsp;0, just to see if this is possible. On our assignment, B would have to be 1 (since &sim;B&nbsp;&nbsp;=&nbsp;&nbsp;0). We don't get a value for the A, and the value matters, since &sim;(?&nbsp;&#8226;&nbsp;1) comes out as unknown. However, we can make the first premise true by making A false, since &sim;(0&nbsp;&#8226;&nbsp;1)&nbsp;&nbsp;=&nbsp;&nbsp;1. So we make A false, which gives us true premises and a false conclusion &ndash; and shows that the argument is invalid:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&sim;(A&#0186; &#8226; B&#0185;)&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;Invalid&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4;&nbsp;&sim;B&#0185;&nbsp;&nbsp;=&nbsp;&nbsp;0</td></tr>
</table></center><br>

In doing the truth-assignment test, remember that:
<ul>
<li>VALID = we can't have premises all true and conclusion false.
<li>INVALID = we can have premises all true and conclusion false.
</ul>
If you don't get a value for a letter but the value matters, try both values (first true and then false); the argument is invalid if either value makes premises all true and conclusion false.<br><br>

<center><font size="5">English Arguments</font></center><br>

You can test an English syllogism by first translating it into symbols (using the same letter for the same idea and different letters for different ideas) &ndash; and then testing the symbolic argument using the truth-assignment test:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If our country will be weak,<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; there will be war.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Our country will not be weak.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; There will not be war.&nbsp;&nbsp;</td><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(K&#0186; &sup; R&#0185;)&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;Invalid&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&sim;K&#0186;&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&there4;&nbsp;&sim;R&#0185;&nbsp;&nbsp;=&nbsp;&nbsp;0</td></tr></table></center><br>

Intuitively, it could be that, while weakness brings war, other things may bring it too.<br><br>
When you do an English argument, first try to give an intuitive appraisal of whether the argument is valid or invalid; then work it out in symbols and see whether this gives the same result. If your intuition clashes with the test, then you made a mistake on one or the other; think about the problem further and try to catch what you did wrong. Using this two-prong attack on arguments trains your logical intuitions and gives you a double-check on the results.<br><br>

<center><font size="5">Idiomatic Arguments</font></center><br>

When people argue in contorted ways, we have to reformulate their reasoning more clearly before we can test for validity. When you deal with such <b>idiomatic arguments</b>, first pick out the <b>conclusion</b> (what is being argued for &ndash; often indicated by words like "hence," "thus," "so," "therefore," "must," or "can't") and the <b>premises</b> (what is being argued from &ndash; often indicated by words like "since," "for," and "because"). Translate the premises and conclusion into logic. If you don't get a valid argument, try adding unstated but implicit premises; using the "principle of charity," interpret unclear reasoning in the way that gives the best argument. Finally, test for validity. Here's an idiomatic argument:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;Knowledge is good in itself only if it&nbsp;&nbsp;<br>
&nbsp;&nbsp;can be desired for its own sake. So&nbsp;&nbsp;<br>
&nbsp;&nbsp;knowledge is good in itself, since it&nbsp;&nbsp;<br>
&nbsp;&nbsp;can be desired for its own sake.&nbsp;&nbsp;</td></tr></table></center><br>

Here the conclusion is "Knowledge is good in itself" &ndash; which we'll translate as "G." The first premise is "Knowledge is good in itself only if it can be desired for its own sake" &ndash; which we'll translate as "(G&nbsp;&sup;&nbsp;C)." If we formulate the rest of the argument and apply the truth-assignment test, we see that the argument is invalid:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(G&#0186; &sup; C&#0185;)&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;Invalid&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&#0185;&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&there4;&nbsp;G&#0186;&nbsp;&nbsp;=&nbsp;&nbsp;0</td></tr></table></center>

<br><A name="F"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set F - Inference Rules</font><br><br>
<font size="5">S-Rules</font></center><br>

<b>S-rules</b> <i>simplify</i> statements. The most important S-rules are <b>AND</b>, <b>NOR</b>, and <b>NIF</b>:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<br><center>&nbsp;&nbsp;&nbsp;<b>AND</b>&nbsp;&nbsp;</center><br></td><td nowrap><center>
<u>(P &#8226; Q)</u><br>
P, Q</center></td><td nowrap><center>
&nbsp;&nbsp;"AND state-&nbsp;&nbsp;<br>
ment so both<br>
parts are true."</center></td></tr><tr><td nowrap>
<br><center><b>NOR</b></center><br></td><td nowrap><center>
&nbsp;&nbsp;<u>&sim;(P &or; Q)</u>&nbsp;&nbsp;<br>
&sim;P, &sim;Q</center></td><td nowrap><center>
&nbsp;&nbsp;"NOT-EITHER &nbsp;&nbsp;<br>
is true, so both<br>
parts are false."</center></td></tr><tr><td nowrap>
<br><center><b>NIF</b></center><br></td><td nowrap><center>
&nbsp;&nbsp;<u>&sim;(P &sup; Q)</u>&nbsp;&nbsp;<br>
P, &sim;Q</center></td><td nowrap><center>
"FALSE IF-THEN,<br>
so first part true,<br>
&nbsp;&nbsp;second part false."&nbsp;&nbsp;</center></td></tr>
</table></center><br>

These work even if the individual parts are negative:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I'm not in Paris and I'm not in Quebec.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; I'm not in Paris.<br>
&nbsp;&nbsp;&there4; I'm not in Quebec.</td><td nowrap><center>
&nbsp;&nbsp;<u>(&sim;P &#8226; &sim;Q)</u>&nbsp;&nbsp;<br>
&sim;P, &sim;Q</center></td></tr>
</table></center><br>
	
But they don't work if we negate the whole formula differently:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're not both in Paris and also in Quebec.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; ???<br>
&nbsp;&nbsp;&there4; ???</td><td nowrap><center>
&nbsp;&nbsp;<u>&sim;(P &#8226; Q)</u>&nbsp;&nbsp;<br>
nil</center></td></tr>
</table></center><br>

You can't be in both cities at the same time. But you might be in Paris (and not Quebec), or in Quebec (and not Paris), or in some third place. From "&sim;(P&nbsp;&#8226;&nbsp;Q)" we can't tell the truth value for P or for Q; we only know that not both are true (at least one is false).<br><br>
This chart shows forms we CAN SIMPLIFY and forms we CAN'T SIMPLIFY:<br><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88 rules=rows>
<tr><td nowrap><center>
&nbsp;&nbsp;CAN SIMPLIFY:&nbsp;&nbsp;</center></td><td nowrap><center>(P&nbsp;&#8226;&nbsp;Q)&nbsp;&nbsp;</center></td><td nowrap><center>&sim;(P&nbsp;&or;&nbsp;Q)&nbsp;&nbsp;</center></td><td nowrap><center>&sim;(P&nbsp;&sup;&nbsp;Q)&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>
&nbsp;&nbsp;CAN'T SIMPLIFY:&nbsp;&nbsp;</center></td><td nowrap><center>&sim;(P&nbsp;&#8226;&nbsp;Q)&nbsp;&nbsp;</center></td><td nowrap><center>(P&nbsp;&or;&nbsp;Q)&nbsp;&nbsp;</center></td><td nowrap><center>(P&nbsp;&sup;&nbsp;Q)&nbsp;&nbsp;</center></td></tr>
</table></center><br>

The S-rules are tricky and you need to learn them to do formal proofs. I suggest that you practice set F a few minutes a day until you get almost every problem right.<br><br>

<center><font size="5">I-Rules</font></center><br>

<b>I-rules</b> <i>infer</i> a conclusion from two premises. The three I-rules are <b>NOT-BOTH</b>, <b>OR</b>, and <b>IF-THEN</b>:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<center><b>&nbsp;&nbsp;NOT-BOTH&nbsp;&nbsp;</b></center></td><td nowrap><center>
&sim;(P &#8226; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
&sim;Q</center>
<P ALIGN=RIGHT>affirm&nbsp;</P>
</td><td nowrap><center>
&sim;(P &#8226; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
&sim;P</center>
<P ALIGN=LEFT>one part</P>
</td><td nowrap>
<center>"NOT-BOTH are<br>true, this one is, so<br>the other one isn't."</center></td></tr><tr><td nowrap>
<center><b>OR</b></center></td><td nowrap><center>
(P &or; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&sim;P&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
Q</center>
<P ALIGN=RIGHT>deny&nbsp;</P>
</td><td nowrap><center>
(P &or; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&sim;Q&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
P</center>
<P ALIGN=LEFT>one part</P>
</td><td nowrap>
<center>"At least one is<br>true, this one isn't,<br>so the other one is."</center> </td></tr>

<tr><td nowrap>
<center><b>IF-THEN</b></center>
</td><td nowrap><center>
(P &sup; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
Q</center>
<P ALIGN=RIGHT>affirm first or</P>
</td><td nowrap><center>
(P &sup; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&sim;Q&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
&sim;P</center>
<P ALIGN=LEFT>&nbsp;deny second</P>
</td><td nowrap>
<center>"IF-THEN, affirm the first,<br>so affirm the second."<br><br>&nbsp;&nbsp;"IF-THEN, deny the second,&nbsp;&nbsp;<br>so deny the first."</center> </td></tr>
</table></center><br>

<div align="justify">For example, we can infer this way:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're not both in Paris and also in Quebec.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're in Paris.<br>
&nbsp;&nbsp;&there4; You're not in Quebec.</td><td nowrap><center>
&sim;(P &#8226; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
&sim;Q</center></td></tr>
</table></center><br>

We can't infer this next way (since the NOT-BOTH form requires that we AFFIRM one part &ndash; and since you might be in Chicago instead):<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're not both in Paris and also in Quebec.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're not in Paris.<br>
&nbsp;&nbsp;&there4; You're in Quebec.</td><td nowrap><center>
&sim;(P &#8226; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&sim;P&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
Q</center></td></tr>
</table></center><br>

But this next one is valid; the second premise "&sim;A" affirms one part since it says the same thing:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;&sim;(&sim;A &#8226; B)&nbsp;<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&sim;A&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
&sim;B</center></td></tr>
</table></center><br>

The most important I-rules are the last two (called <b>IF-THEN</b>, or <i>modus ponens</i> / <i>modus tollens</i>):<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If-then.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Affirm first.<br>
&nbsp;&nbsp;&there4; Affirm second.&nbsp;&nbsp;</td><td nowrap><center>
(P &sup; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
Q</center></td></tr><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If-then.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Deny second.<br>
&nbsp;&nbsp;&there4; Deny first.</td><td nowrap><center>
(P &sup; Q)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp; &sim;Q &nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
&sim;P</center></td></tr></table></center><br>

To infer with an if-then, we must <b>affirm the first part</b> or <b>deny the second part</b>. These two examples are valid:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you're a dog, you're an animal.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're a dog.<br>
&nbsp;&nbsp;&there4; You're an animal.&nbsp;&nbsp;</td><td nowrap><center>
(D &sup; A)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
A</center></td></tr><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you're a dog, you're an animal.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're not an animal.<br>
&nbsp;&nbsp;&there4; You're not a dog.</td><td nowrap><center>
(D &sup; A)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp; &sim;A &nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
&sim;D</center></td></tr></table></center><br>

However, these two are invalid, where we <b>deny the first part</b> or <b>affirm the second part</b>, since you might be a cat-type animal instead:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you're a dog, you're an animal.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're not a dog.<br>
&nbsp;&nbsp;&there4; You're not an animal.&nbsp;&nbsp;</td><td nowrap><center>
(D &sup; A)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp; &sim;D &nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
&sim;A</center></td></tr><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you're a dog, you're an animal.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're an animal.<br>
&nbsp;&nbsp;&there4; You're a dog.</td><td nowrap><center>
(D &sup; A)<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
D</center></td></tr></table></center><br>

To "affirm" a part means to say the same thing, and to "deny" a part means to say the opposite. So in this example &ndash; which is valid &ndash; we correctly deny the second part of the if-then and conclude the denial of the first part:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;(&sim;A &sup; &sim;B)&nbsp;<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
A</center></td></tr>
</table></center><br>

When we start to do formal proofs, we'll often use the S- and I-rules on larger formulas. Suppose that we have this premise: "((A &#8226; B) &sup; (C &or; D))." We can infer with this if we have the first part true; then we can conclude that the second part is true:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;((A &#8226; B) &sup; (C &or; D))&nbsp;<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (A &#8226; B) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
(C &or; D)</center></td></tr>
</table></center><br>

Likewise, we can infer if we have the second part false; then we can conclude that the first part is false:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;((A &#8226; B) &sup; (C &or; D))&nbsp;<br>
&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&sim;(C &or; D)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;<br>
&sim;(A &#8226; B)</center></td></tr>
</table></center><br>

The I-rules are tricky and you need to learn them to do formal proofs. I suggest that you practice set F a few minutes a day until you get almost every problem right.<br>

<br><A name="G"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set G - Propositional Proofs</font><br><br>
<font size="5">Doing Proofs in LogiCola</font></center><br>
A LogiCola proof problem begins like this:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(S &sup; &sim;C)<br>
&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;(S &or; &sim;A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&sim;(A &#8226; C)<br><br>
&nbsp;&nbsp;What's next, Harry? _<br><br>
&nbsp;&nbsp;TO ANSWER: Type a derived line ("A"), assumption<br>
&nbsp;&nbsp;("ASM: A"), or "REFUTE" (to finish an invalid argument).&nbsp;&nbsp;<br>
&nbsp;&nbsp;Click a wff (or use PgUp-PgDn keys) to copy it to the<br>
&nbsp;&nbsp;answer space. "Info" reviews the rules.<br></td></tr></table></center><br>

You type formulas until the proof is completed. First assume the opposite of the conclusion by typing <nobr>"ASM: (A &#8226; C)."</nobr> LogiCola will accept this answer, add it to the proof, and ask for the next line.<p>
LogiCola rejects lines that are poor strategy or violate the inference rules. Then you get the "Sorry, I don't like your answer" message and have to try again. On your first error, you get a hint about what to do next; on your second, you're told what answer to give. For some typing errors, such as not balancing parentheses, you're given a hint but don't lose points.<p>
You could complete the proof this way:<br><br>

<center><table border="2" rules=cols bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;*&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(S &sup; &sim;C)<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;(S &or; &sim;A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&sim;(A &#8226; C)<br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&#9484;&nbsp;asm: (A &#8226; C)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;&there4;&nbsp;A&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9474;&nbsp;&there4;&nbsp;C&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&#9474;&nbsp;&there4;&nbsp;&sim;S&nbsp;&nbsp;{from 1 and 5}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&#9492;&nbsp;&there4;&nbsp;&sim;A&nbsp;&nbsp;{from 2 and 6}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&there4;&nbsp;&sim;(A &#8226; C)&nbsp;&nbsp;{from 3; 4 contradicts 7}&nbsp;&nbsp;</td>
<td nowrap><center>
Here<br>you type<br><br>&nbsp;&nbsp;<b>ASM: (A &#8226; C)</b>&nbsp;&nbsp;<br><b>A</b><br><b>C</b><br><b>&sim;S</b><br><b>&sim;A</b><br><b>&sim;(A &#8226; C)</b>
</center></td>

</tr></table></center><br>

You keep typing the next formula. Don't type line numbers, justifications, "&there4;" for "therefore," or stars; LogiCola types these for you. To derive a formula from previous lines, just type the formula and hit ENTER. You could do this sample proof in various other ways; for example, you could derive "S" in lines 6 or 7. LogiCola accepts any way to do the proof that accords with our normal strategy.<p>

You can click a previous formula to put it into the answer space. So instead of typing <nobr>"ASM: (A &#8226; C)"</nobr> to begin the proof, you can click the original conclusion, which puts <nobr>"&sim;(A &#8226; C)"</nobr> into the answer space, and then replace "&sim;" with "ASM:"; as formulas get longer, this clicking technique can save you time and minimize typing errors.<p>

With invalid arguments, do the proof as far as you can and then type "REFUTE." LogiCola uses the lines you've derived to construct a refutation &ndash; truth conditions making premises all true and conclusion false.<p>

If you get confused on what to do, you can click GETANS ("Get answer") to have LogiCola give you the next line. You normally lose points for this; but if LogiCola just rejected your answer, you won't lose further points.<p>

Proof exercises have two special settings:
<ul>
<li>STARRING: Normally use the "program stars" setting. To make sure you understand how to star, you might occasionally use "you star," which keeps asking you about which lines get starred; you don't lose points for mistakes about starring.
<li>TRAINING WHEELS (like when you learn to ride a bicycle): If you have this "on," you get hints about what line to derive next -- and the lines to derive from are bolded; the hints cease when you reach 15 points and the bolding ceases when you reach 30 points. (Note that the hints give ONE way to do the proof, but not necessarily the only way.)
</ul>
These two settings don't impact how your exercise is scores; so you get credit for the "GEV" exercise, for example, regardless of how these settings are set.<p>

Here are two more things. (1) You needn't capitalize correctly in <i>proof</i> exercises (as opposed to <i>translation</i> exercises); the program will correct for capitalization errors in proof exercises. (2) If you are running out of screen space, the program will finish the proof for you.<br><br>

<center><font size="5">Basic Formal Proofs</font></center><br>

For propositional proofs, we'll use these inference rules, which hold regardless of what pairs of contradictory wffs replace "P" / "&sim;P" and "Q" / "&sim;Q" (here "&#8658;" means we can infer whole lines from left to right):<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>S-rules (Simplifying)</center></td>
<td nowrap><center>I-rules (Inferring)</center></td></tr><tr><td nowrap><center>
(P &#8226; Q)&nbsp;&nbsp;&#8658;&nbsp;&nbsp;P, Q<br>
&sim;(P &or; Q)&nbsp;&nbsp;&#8658;&nbsp;&nbsp;&sim;P, &sim;Q<br>
&sim;(P &sup; Q)&nbsp;&nbsp;&#8658;&nbsp;&nbsp;P, &sim;Q<br>
&sim;&sim;P&nbsp;&nbsp;&#8658;&nbsp;&nbsp;P<br>
(P &equiv; Q)&nbsp;&nbsp;&#8658;&nbsp;&nbsp;(P &sup; Q), (Q &sup; P)<br>
&nbsp;&nbsp;&sim;(P &equiv; Q)&nbsp;&nbsp;&#8658;&nbsp;&nbsp;(P &or; Q), &sim;(P &#8226; Q)&nbsp;&nbsp;</center></td><td nowrap><center>
&sim;(P &#8226; Q), P&nbsp;&nbsp;&#8658;&nbsp;&nbsp;&sim;Q<br>
&sim;(P &#8226; Q), Q&nbsp;&nbsp;&#8658;&nbsp;&nbsp;&sim;P<br>
(P &or; Q), &sim;P&nbsp;&nbsp;&#8658;&nbsp;&nbsp;Q<br>
(P &or; Q), &sim;Q&nbsp;&nbsp;&#8658;&nbsp;&nbsp;P<br>
(P &sup; Q), P&nbsp;&nbsp;&#8658;&nbsp;&nbsp;Q<br>
&nbsp;&nbsp;(P &sup; Q), &sim;Q&nbsp;&nbsp;&#8658;&nbsp;&nbsp;&sim;P&nbsp;&nbsp;</center></td></tr></table></center><br>
	
We'll do "indirect proofs," where we assume the opposite of what we want to prove and then derive a contradiction; then the original conclusion follows. This style of proof uses RAA (which stands for "reductio ad absurdum" &ndash; reduction to absurdity):<br>

<ul><b>RAA</b>: Suppose that some pair of not-blocked-off lines has contradictory wffs. Then block off all the lines from the last not-blocked-off assumption on down and infer a line consisting in "&there4;" followed by a contradictory of that assumption.</ul>

Our proof system is characterized by these definitions:
<ul>
<li>A <b>premise</b> is a line consisting of a wff by itself (with no "&there4;" or "asm:").
<li>An <b>assumption</b> is a line consisting of "asm:" and then a wff.
<li>A <b>derived line</b> is a line consisting of "&there4;" and then a wff.
<li>A <b>formal proof</b> is a vertical sequence of zero or more premises followed by one or more assumptions or derived lines, where each derived line follows from previously not-blocked-off lines by one of the S- and I-rules listed above or by RAA, and each assumption is blocked off using RAA.
<li>Two wffs are <b>contradictories</b> if they are exactly alike except that one starts with an additional "&sim;."
<li>A <b>simple</b> wff is a letter or its negation; any other wff is <b>complex</b>.
</ul>

A provisional form of our proof strategy goes as follows (here starring a line indicates that you can ignore it for the rest of the proof):
<ol>
<li><b>START</b>: Block off the conclusion and add "asm:" followed by the conclusion's simpler contradictory.
<li><b>S&I</b>: Go through the complex wffs that aren't starred or blocked off and use these to derive new wffs using S- and I-rules. Star any wff you simplify using an S-rule, or the longer wff used in an I-rule inference.
<li><b>RAA</b>: When some pair of not-blocked-off lines contradict, apply RAA and derive the original conclusion. Your proof is done.
</ol>

Here's a very simple proof:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;*&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(A &sup; B)&nbsp;&nbsp;&nbsp;&nbsp;Valid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;(&sim;A &or; B)<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&#9484;&nbsp;asm: &sim;(&sim;A &or; B)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&#9474;&nbsp;&there4;&nbsp;A&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;&there4;&nbsp;&sim;B&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9492;&nbsp;&there4;&nbsp;B&nbsp;&nbsp;{from 1 and 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&there4;&nbsp;(&sim;A &or; B)&nbsp;&nbsp;{from 2; 4 contradicts 5}&nbsp;&nbsp;</td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 2). We derive further lines using the S- and I-rules until we get a contradiction (lines 3 to 5). Finally, we apply RAA to complete the proof (line 6).<br><br>

<center><font size="5">Invalid Arguments</font></center><br>

If you attempt to prove an invalid argument, you won't succeed; instead, you'll get a refutation. A <b>refutation</b> is a set of truth conditions (assignments of "1" and "0" to the letters) that makes premises all true and conclusion false. A refutation shows the argument to be invalid, just as a proof shows the argument to be valid. So now we'll try to prove valid arguments (by giving proofs) &ndash; and refute invalid arguments (by giving refutations).<br><br>

A still provisional form of our proof strategy goes as follows:
<ol>
<li><b>START</b>: Block off the conclusion and add "asm:" followed by the conclusion's simpler contradictory.
<li><b>S&I</b>: Go through the complex wffs that aren't starred or blocked off and use these to derive new wffs using S- and I-rules. Star any wff you simplify using an S-rule, or the longer wff used in an I-rule inference. If you get a contradiction, apply RAA (line 3). If you can derive nothing further and yet have no contradiction, then refute (line 4).
<li><b>RAA</b>: Since you have a contradiction, apply RAA. You've proved the argument valid.
<li><b>REFUTE</b>: You have no contradiction and yet can't derive anything else. Draw a box containing any simple wffs (letters or their negation) that aren't blocked off. In the original argument, mark each letter "1" or "0" or "?" depending on whether you have the letter or its negation or neither in the box. If these truth conditions make the premises all true and conclusion false, then this shows the argument to be invalid.
</ol>

While this strategy works most of the time, we'll see later that some propositional arguments require a more powerful strategy for getting a proof or refutation.<br><br>
Here's how this strategy applies to a very simple argument:<br><br>

<center><table border="2" rules=cols bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(A&#0186; &sup; B&#0185;)&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;(B&#0185; &sup; A&#0186;)&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;asm: &sim;(B &sup; A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;B&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&sim;A&nbsp;&nbsp;{from 2}&nbsp;&nbsp;<br></td><td nowrap bordercolor=#000000  bgcolor=#FFFF88><center>
&nbsp;&nbsp;Invalid&nbsp;&nbsp;<br><br>
B, &sim;A</center></td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 2). We derive all we can using the S- and I-rules (lines 3 and 4). Since we get no contradiction, we instead collect the simple wffs to get a refutation (in the right-hand box). We also could write the refutation box this way:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap><center>
Invalid<br><br>
&nbsp;&nbsp;B&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;A&nbsp;&nbsp;=&nbsp;&nbsp;0&nbsp;&nbsp;</center></td></tr></table></center><br>

So we make B true and A false and check that this makes premises all true and conclusion false. Since it does, the argument is shown to be invalid.<br><br>
If our refutation doesn't work, then we did something wrong. The line that comes out wrong (a premise that's 0 or ?, or a conclusion that's 1 or ?) is the source of the problem; we did something wrong with it &ndash; either deriving something wrongly or else not deriving something that we should have derived. So plugging in the values can help us to find errors.<br><br>

<center><font size="5">Multiple-Assumption Arguments</font></center><br>

Some arguments require further assumptions. You make a further assumption when you get stuck. Here's the final form of our propositional proof strategy (here a complex wff is "broken" if we have one side or its negation as a not-blocked-off line in the proof):
<ol>
<li><b>START</b>: Block off the conclusion and add "asm:" followed by the conclusion's simpler contradictory.
<li><b>S&I</b>: Go through the complex wffs that aren't starred or blocked off and use these to derive new wffs using S- and I-rules. Star (with one star for each live assumption) any wff you simplify using an S-rule, or the longer wff used in an I-rule inference. If you get a contradiction, then go to RAA (line 3). If you can't derive anything further but there is a complex wff that isn't starred or blocked off or broken, then go to ASSUME (line 4). If you can't derive anything further and every complex wff is starred or blocked off or broken, then go to REFUTE (line 5).
<li><b>RAA</b>: Apply the RAA rule. If all assumptions are now blocked off, you've proved the argument valid. Otherwise, erase star strings having more stars than the number of live assumptions and return to line 2.
<li><b>ASSUME</b>: Pick a complex wff that isn't starred or blocked off or broken. This wff will have one of these forms: "&sim;(A&nbsp;&#8226;&nbsp;B)," "(A&nbsp;&or;&nbsp;B)," or "(A&nbsp;&sup;&nbsp;B)." Assume one side or its negation and return to line 2.
<li><b>REFUTE</b>: Construct a refutation box. Put into the box any simple wffs (letters or their negation) that aren't blocked off. In the original argument, mark each letter "1" or "0" or "?" depending on whether the box has the letter or its negation or neither. These truth conditions should make the premises all true and conclusion false &ndash; thus showing the argument to be invalid.
</ol>

Correctly applied, our revised procedure will always generate a proof or a refutation. Here's a multiple-assumption proof:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;*&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(B &or; A)&nbsp;&nbsp;&nbsp;&nbsp;Valid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;(B &sup; A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&sim;(A &sup; &sim;A)<br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&#9484;&nbsp;asm: (A &sup; &sim;A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&#9474;&#9484;&nbsp;asm: B&nbsp;&nbsp;{break 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9474;&#9474;&nbsp;&there4;&nbsp;A&nbsp;&nbsp;{from 2 and 4}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&#9474;&#9492;&nbsp;&there4;&nbsp;&sim;A&nbsp;&nbsp;{from 3 and 5}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&#9474;&nbsp;&there4;&nbsp;&sim;B&nbsp;&nbsp;{from 4; 5 contradicts 6}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&#9474;&nbsp;&there4;&nbsp;A&nbsp;&nbsp;{from 1 and 7}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&#9492;&nbsp;&there4;&nbsp;&sim;A&nbsp;&nbsp;{from 3 and 8}<br>
&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&there4;&nbsp;&sim;(A &sup; &sim;A)&nbsp;&nbsp;{from 3; 8 contradicts 9}&nbsp;&nbsp;</td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 3). Since we can't derive anything else, we make another assumption (line 4). We derive further lines using the S- and I-rules until we get a contradiction (lines 5 and 6). Then we kill the previous assumption and derive the opposite (line 7). We derive further lines using the S- and I-rules until we get a second contradiction (lines 8 and 9). Finally, we apply RAA to complete the proof (line 10).<br><br>
When we apply RAA on an assumption, we block off the lines from the assumption on down &ndash; showing that we can't use these lines in deriving further lines or in getting a contradiction. In the above proof, after we block off lines 4 to 6 we can't use them any more; their only function was to give us line 7.<br><br>
This invalid argument uses multiple assumptions:<br><br>

<center><table border="2" rules=cols bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(A&#0185; &or; &sim;(B &sup; C&#0185;))&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;(D&#0186; &sup; (A&#0185; &sup; B))&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;(C&#0185; &sup; &sim;(D&#0186; &or; A&#0185;))&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;asm: &sim;(C &sup; &sim;(D &or; A))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;C&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;(D &or; A)&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asm:&nbsp;A&nbsp;&nbsp;{break 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asm:&nbsp;&nbsp;&there4;&nbsp;&sim;D&nbsp;&nbsp;{break 2}&nbsp;&nbsp;</td><td nowrap><center>
Invalid<br><br>
&nbsp;&nbspC, A, &sim;D&nbsp;&nbsp;</center></td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 3). We derive lines 4 and 5, but get no contradiction. Since we can't derive anything else, we make another assumption (line 6). Since we still can't derive anything else, we make a third assumption (line 7). At this point, we could use line 5 with 7 to derive "A" &ndash; but we already have this in line 6, so we don't do it. Also, we don't make another assumption on line 5, since we don't make an assumption on a wff if we already have one side or its negation. So, being unable to derive or assume anything else, we collect the simple wffs to get a refutation. We check that having C and A true and D false makes premises all true and conclusion false. Since it does, the argument is shown to be invalid.<br><br>
With our full proof strategy, we keep going until one of these things happens:
<ul>
<li>Every assumption leads to a contradiction. Then we have a proof of validity.
<li>We can't derive anything further (using S- or I-rules or RAA) and every complex wff is starred or blocked off or broken. (A complex wff is "broken" if we have one side or its negation as a not-blocked-off line in the proof.) Then the remaining simple wffs will give a refutation that proves invalidity.
</ul>
In the second case, we sometimes end by making several assumptions that help to give us our refutation. Invalid arguments frequently require three or more assumptions.<br><br>

<center><font size="5">Copi Proofs</font></center><br>

Copi proofs are a traditional way of doing proofs (see section 7.5 of the third edition of Gensler's logic book). To do these in set G, pick "Copi Proofs" and the level of difficulty (Easier / Harder / Mixed); you get the same randomly generated problems (but only valid ones) as with our regular proofs. You repeatedly type the next wff, click (or touch) the inference rule, and then click (or touch) the previous wffs from which your step follows. There are no arrows to get the next line or finish the problem; but you can quit the problem (which costs you points) or paste your own problems (or ones from your teacher). You can also copy previous lines or the conclusion into the answer space, so you can modify them to give your next line. While Copi proofs are difficult, youll soon get the hang of it.<br><br>

<center><font size="5">Truth Trees</font></center><br>

Truth treees are a common graphical method of testing arguments (see section 7.6 of the third edition of Gensler's logic book); truth trees break formulas into the cases that make them true. To do these in set G, pick Treez and the level of difficulty (Easier / Harder / Mixed); you get the same randomly generated problems (valid and invalid) as with regular proofs. You do this exercise entirely by clicking or touching (no typing); follow the directions at the bottom. The "program closes branches" option automatically closes self-contradictory branches, while "you close branches" has you close these yourself (but without losing points for errors). The "automatic double-negation" option simplifies double negations automatically (so &sim;(A &or; &sim;B) simplifies into &sim;A and B  instead of &sim;A and &sim;&sim;B). You can click or touch an arrow at the top to give you the next line or finish the problem (but without getting credit for the problem); you can use these to step through sample proofs before starting them on your own.<br>

<br><A name="H"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set H - Quantificational Translations</font><br><br>
<font size="5">Easier Translations</font></center><br>

<b>Quantificational logic</b> studies arguments whose validity depends on "all," "no," "some," and similar notions. It builds on propositional logic and adds two new vocabulary items: small letters and "&exist;":<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;Ir</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Romeo is Italian.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;Ix</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
x is Italian.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(x)Ix</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
All are Italian.<br>For all x, x is Italian.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(&exist;x)Ix</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Some are Italian.<br>For some x, x is Italian.&nbsp;&nbsp;</td></tr></table></center><br>

Capital letters and small letters have various uses:
<ul>
<li>A <b>capital letter</b> alone (not followed by small letters) represents a <b>statement</b> (so "S" = "It is snowing"). A capital letter followed by a single small letter represents a <b>general term</b> (so "Ir" = "Romeo is Italian").
<li>A <b>small letter</b> from "a" to "w" is a <b>constant</b> &ndash; and stands for a specific person or thing (so "r" might stand for Romeo). A small letter from "x" to "z" is a <b>variable</b> &ndash; and stands for an unspecified person or thing (so "Ix" = "x is Italian" &ndash; with "x" serving as a variable).
</ul>
A <b>quantifier</b> is a sequence of the form "(x)" or "(&exist;x)" &ndash; where any other variable may replace "x":
<ul>
<li>"(x)" is a <b>universal quantifier</b>. It claims that the formula that follows is true for all values of x. So "(x)Ix" = "All are Italian" = "For all x, x is Italian."
<li>"(&exist;x)" is an <b>existential quantifier</b>. It claims that the formula that follows is true for at least one value of x. So "(&exist;x)Ix" = "Some are Italian" = "For some x, x is Italian."
</ul>
We have two new ways to form <b>wffs</b>, in addition to those used in propositional logic:
<ol>
<li>The result of writing a capital letter and then a small letter is a wff.
<li>The result of writing a quantifier and then a wff is a wff.
</ol>

We'll begin with easier translations &ndash; with English sentences that translate into wffs starting with a quantifier, or with "&sim;" and then a quantifier. This rule tells where to put what quantifier:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;If the English begins with&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;then begin the wff with&nbsp;&nbsp;</center></td></tr><tr><td nowrap><center>
all (every)<br>
not all (not every)<br>
some<br>
no</center></td><td nowrap><center>
(x)<br>
&sim;(x)<br>
(&exist;x)<br>
&sim;(&exist;x)</center></td></tr></table></center><br>

Here are examples:<br><br>

<center>
<table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;Everyone is Italian</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
(x)Ix&nbsp;&nbsp;</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;Not all are Italian</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
&sim;(x)Ix&nbsp;&nbsp;</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;Some are Italian</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
(&exist;x)Ix&nbsp;&nbsp;</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;No one is Italian</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
&sim;(&exist;x)Ix&nbsp;&nbsp;</td></tr></table></center><br>

If the English sentence uses "or," "and," or "if-then," then use the corresponding logical connective; so "All are Germans or Italians" is "(x)(Gx &or; Ix)." When the English doesn't specify the connective, use these rules:<br><br>

<center>
<table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
With "all ... is ...,"<br>
use "&sup;" for the<br>
&nbsp;&nbsp;middle connective.&nbsp;&nbsp;</center></td><td nowrap><center>
&nbsp;&nbsp;Otherwise use&nbsp;&nbsp;<br>
"&#8226;" for the<br>
connective.</center></td></tr></table></center><br>

Here are examples:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
All Italians are lovers&nbsp;&nbsp;=&nbsp;&nbsp;(x)(Ix &sup; Lx)<br>
(For all x, if x is Italian then x is a lover.)
</center></td></tr><tr><td nowrap><center>
Some Italians are lovers&nbsp;&nbsp;=&nbsp;&nbsp;(&exist;x)(Ix &#8226; Lx)<br>
(For some x, x is Italian and x is a lover.)
</center></td></tr><tr><td nowrap><center>
No Italians are lovers&nbsp;&nbsp;=&nbsp;&nbsp;&sim;(&exist;x)(Ix &#8226; Lx)<br>
&nbsp;&nbsp;(It is not the case that, for some x, x is Italian and x is a lover.)&nbsp;&nbsp;
</center></td></tr><tr><td nowrap><center>
All rich Italians are lovers&nbsp;&nbsp;=&nbsp;&nbsp;(x)((Rx &#8226; Ix) &sup; Lx)<br>
(For all x, if x is rich and x is Italian, then x is a lover.)
</center></td></tr></table></center><br>

In the last example, "&sup;" comes from the "middle connective" rule ("<i>if</i> rich Italian <i>then</i> lover") and "&#8226;" from the "otherwise" rule ("if rich <i>and</i> Italian then lover").<br><br>

<center><font size="5">Harder Translations</font></center><br>

Harder translations use some of these additional features:
<ul>
<li>Capital letters alone (not followed by small letters) represent whole statements &ndash; like "S" for "It's snowing."
<li>Small letters from "a" to "w" represent singular terms (terms that stand for a specific person or thing) &ndash; like "r" for "Romeo" or "p" for "the current president."
<li>Some formulas use two or more quantifiers, or quantifiers that are not near the beginning of the formula.
</ul>
Here's a long formula that uses all these features:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;&nbsp;If all Greeks are mortal and Socrates is Greek,&nbsp;&nbsp;
<br>&nbsp;&nbsp;then someone is mortal and it will rain&nbsp;&nbsp;<br>=<br>&nbsp;&nbsp;(((x)(Gx &sup; Mx) &#8226; Gs) &sup; ((&exist;x)Mx &#8226; R))&nbsp;&nbsp;
</center></td></tr></table></center><br>

We need to expand our rule about where to put quantifiers to this:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Wherever the English has&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;put this in the wff&nbsp;&nbsp;</center></td></tr><tr><td nowrap><center>
all (every)<br>
not all (not every)<br>
some<br>
no</center></td><td nowrap><center>
(x)<br>
&sim;(x)<br>
(&exist;x)<br>
&sim;(&exist;x)</center></td></tr></table></center><br>

Here are examples:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;&nbsp;If all are Italians, then not all are Germans&nbsp;&nbsp;<br>((x)Ix &sup; &sim;(x)Gx)
</center></td></tr><tr><td nowrap><center>
&nbsp;&nbsp;Either some are Italians or no one is Italian&nbsp;&nbsp;<br>((&exist;x)Ix &or; &sim;(&exist;x)Ix)
</center></td></tr></table></center><br>

Use a separate quantifier for each "all," "some," and "no." And mimic the English word order:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;not all&nbsp;&nbsp;=&nbsp;&nbsp;&sim;(x)&nbsp;&nbsp;<br>&nbsp;&nbsp;all not&nbsp;&nbsp;=&nbsp;&nbsp;(x)&sim;&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;all either&nbsp;&nbsp;=&nbsp;&nbsp;(x)(&nbsp;&nbsp;<br>&nbsp;&nbsp;either all&nbsp;&nbsp;=&nbsp;&nbsp;((x)&nbsp;&nbsp;</center></td></tr></table></center><br>

"Any" is an exception and is governed by two different but equivalent rules:
<ol>
<li>To translate "any," put a "(x)" at the <i>beginning</i> of the wff, regardless of where the "any" occurs in the sentence.
<li>To translate "any," first rephrase the sentence so it means the same thing but doesn't use "any"; then translate the second sentence.
</ol>

These two methods often give different, but equivalent, translations. It's good to know both methods, because sometimes one is easier to apply. Here are examples of translations using these two methods:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&nbsp;&nbsp;Not anyone is rich&nbsp;&nbsp;=&nbsp;&nbsp;No one is rich&nbsp;&nbsp;<br>(x)&sim;Rx&nbsp;&nbsp;=&nbsp;&nbsp;&sim;(&exist;x)Rx&nbsp;&nbsp;
</center></td></tr><tr><td nowrap><center>
&nbsp;&nbsp;If anyone is just, there will be peace&nbsp;&nbsp;=&nbsp;&nbsp;If some are just, ...&nbsp;&nbsp;<br>(x)(Jx &sup; P)&nbsp;&nbsp;=&nbsp;&nbsp;((&exist;x)Jx &sup; P)&nbsp;&nbsp;
</center></td></tr><tr><td nowrap><center>
&nbsp;&nbsp;Not any Italians are lovers&nbsp;&nbsp;=&nbsp;&nbsp;No Italians are lovers&nbsp;&nbsp;<br>(x)&sim;(Ix &#8226; Lx)&nbsp;&nbsp;=&nbsp;&nbsp;&sim;(&exist;x)(Ix &#8226; Lx)&nbsp;&nbsp;
</center></td></tr></table></center><br>

Our translation rules are rough and sometimes can give a wrong translation. After you translate from English, read your formula over carefully to make sure it means the same as the original sentence.<br><br>

<center><font size="5">Identity Translations</font></center><br>

<b>Identity logic</b> adds to quantificational logic the "=" symbol and this formation rule:
<ul>
<li>The result of writing a small letter and then "=" and then a small letter is a wff.
</ul>
Compare these two:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>Romeo is a lover</center></td>
<td nowrap><center>&nbsp;&nbsp;Lr&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;Predication&nbsp;&nbsp;</center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;Romeo is the lover of Juliet&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;r=l&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;Identity&nbsp;&nbsp;</center></td></tr></table></center><br>

Use small letters for singular terms (terms that stand for a specific person or thing &ndash; like "Romeo" or "the lover of Juliet"); use capital letters for general terms (terms that do or could describe more than one person or thing &ndash; like "Italian" or "a lover"). Use "=" to link small letters. "a=b" is equivalent to "b=a" and to "a is the same entity as b." Here are further translations involving identity:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Romeo isn't the lover of Juliet&nbsp;&nbsp;<br>&sim;r=l</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Someone besides (who isn't) Romeo is rich&nbsp;&nbsp;<br>(&exist;x)(&sim;x=r &#8226; Rx)</td></tr>
<tr><td nowrap><center>Romeo alone is rich<br>
&nbsp;&nbsp;(Romeo is rich and no one besides Romeo is rich)&nbsp;&nbsp;<br>(Rr &#8226; &sim;(&exist;x)(&sim;x=r &#8226; Rx))</center></td></tr></table></center><br>

We can translate some numerical notions using identity:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;There is exactly one Italian&nbsp;&nbsp;<br>(&exist;x)(Ix &#8226; &sim;(&exist;y)(&sim;y=x &#8226; Iy))</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;There are at least two Italians&nbsp;&nbsp;<br>(&exist;x)(&exist;y)(&sim;x=y &#8226; (Ix &#8226; Iy))</td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;There are exactly two Italians&nbsp;&nbsp;<br>&nbsp;&nbsp;(&exist;x)(&exist;y)((&sim;x=y &#8226; (Ix &#8226; Iy)) &#8226; &sim;(&exist;z)((&sim;z=x &#8226; &sim;z=y) &#8226; Iz))&nbsp;&nbsp;</center></td></tr></table></center><br>

<center><font size="5">Relational Translations</font></center><br>

<b>Relational logic</b> adds to quantificational logic this formation rule:
<ul>
<li>The result of writing a capital letter and then two or more small letters is a wff.
</ul>

A capital letter followed by two or more small letters stands for a relation. So "Lxy" might mean "x loves y" &ndash; and "Gxyz" might mean "x gave y to x." Relational translations are difficult, with few rules to help you. Here are some examples without quantifiers:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>Romeo loves Juliet<br>Lrj</center></td></tr>
<tr><td nowrap><center>Juliet loves Romeo<br>Ljr</td></tr>
<tr><td nowrap><center>Juliet loves herself<br>Ljj</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Juliet loves Romeo and Antonio&nbsp;&nbsp;<br>(Ljr &#8226; Lja)</center></td></tr>
</table></center><br>

These examples have a single quantifier:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Everyone loves Juliet&nbsp;&nbsp;<br>(x)Lxj</center></td></tr>
<tr><td nowrap><center>Someone loves Juliet<br>(&exist;x)Lx</center></td></tr>
<tr><td nowrap><center>No one loves Juliet<br>&sim;(&exist;x)Lxj</center></td></tr>
</table></center><br>

If English puts a quantifier word <i>after</i> the relation, then logic puts the quantifier <i>before</i> the relation. So "Juliet loves everyone (someone, no one)" means "For all (some, no) x, Juliet loves x":<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Juliet loves everyone&nbsp;&nbsp;<br>(x)Ljx</center></td></tr>
<tr><td nowrap><center>Juliet loves someone<br>(&exist;x)Ljx</center></td></tr>
<tr><td nowrap><center>Juliet loves no one<br>&sim;(&exist;x)Ljx</center></td></tr>
</table></center><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Juliet loves every Italian&nbsp;&nbsp;<br>(x)(Ix &sup; Ljx)</center></td></tr>
<tr><td nowrap><center>Juliet loves some Italian<br>(&exist;x)(Ix &#8226; Ljx)</center></td></tr>
<tr><td nowrap><center>Juliet loves no Italian<br>&sim;(&exist;x)(Ix &#8226; Ljx)</center></td></tr>
</table></center><br>

These examples have two quantifiers:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>Everyone loves everyone<br>(x)(y)Lxy</center></td></tr>
<tr><td nowrap><center>Someone loves someone<br>(&exist;x)(&exist;y)Lxy</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Everyone loves everyone else&nbsp;&nbsp;<br>(x)(y)(&sim;x=y &sup; Lxy)</center></td></tr>
<tr><td nowrap><center>Someone loves someone else<br>(&exist;x)(&exist;y)(&sim;x=y &#8226; Lxy)</center></td></tr>
</table></center><br>

The last two are importantly different &ndash; but often confused:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>Everyone loves someone or other<br>(x)(&exist;y)Lxy</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;There is someone that everyone loves&nbsp;&nbsp;<br>(&exist;y)(x)Lxy</center></td></tr>
</table></center><br>

In the first case, everyone might love a different person. In the second case, there is some one person that everyone loves.<br><br>

These examples are harder:<br><br>

<center>
<table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>Every Italian loves some German or other<br>(x)(Ix &sup; (&exist;y)(Gy &#8226; Lxy))</center></td></tr>
<tr><td nowrap><center>
It's always the case that if a first person understands<br>
a second then the first loves the second<br>(x)(y)(Uxy &sup; Lxy)</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Romeo loves all and only those who don't love themselves&nbsp;&nbsp;<br>(x)(Lrx &equiv; &sim;Lxx)</center></td></tr>
<tr><td nowrap><center>There is an unloved lover<br>(&exist;x)(&sim;(&exist;y)Lyx &#8226; (&exist;z)Lxz)</center></td></tr>
</table></center>

<br><A name="I"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set I - Quantificational Proofs</font><br><br>
<font size="5">Easier Proofs</font></center><br>

<b>Quantificational proofs</b> work like propositional proofs, but add these four inference rules (where "Fx" can be any wff using a given variable, while "Fa" is similar except that the same constant replaces each occurrence of this variable):<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap><center>&nbsp;&nbsp;Reverse squiggles&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;&sim;(x)Fx&nbsp;&nbsp;&#8658;&nbsp;&nbsp;(&exist;x)&sim;Fx&nbsp;&nbsp;<br>&nbsp;&nbsp;&sim;(&exist;x)Fx&nbsp;&nbsp;&#8658;&nbsp;&nbsp;(x)&sim;Fx&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Drop existentials&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;(&exist;x)Fx&nbsp;&nbsp;&#8658;&nbsp;&nbsp;Fa,&nbsp;&nbsp;<br>&nbsp;&nbsp;use a <b>new</b> constant&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Drop universals&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;(x)Fx&nbsp;&nbsp;&#8658;&nbsp;&nbsp;Fa,&nbsp;&nbsp;<br>&nbsp;&nbsp;use any constant&nbsp;&nbsp;</center></td></tr>
</table></center><br>

A constant letter is <b>old</b> if it already occurs in the argument; otherwise it's <b>new</b>.<br><br>

Our proof strategy still uses START, S&I, RAA, ASSUME and REFUTE. It adds these to the S&I part:
<ol>
<li><b>First reverse squiggles</b>: For each unstarred, not-blocked-off line that begins with "&sim;" and then a quantifier, derive a line using the reverse-squiggle rules. Star the original line.
<li><b>And drop existentials</b>: For each unstarred, not-blocked-off line that begins with an existential quantifier, derive an instance using the next available <i>new</i> constant (unless some such instance already occurs in previous not-blocked-off lines lines). Star the original line.
<li><b>Lastly drop universals</b>: For each not-blocked-off line that begins with a universal quantifier, derive instances using each <i>old</i> constant. Don't star the original line; you might have to use it again. Note: Drop a universal using a <i>not-blocked-off linesnew</i> letter only if you've done everything else possible (making further assumptions if needed) and still have no old letters; this is unusual, but happens if we try to prove "(x)&sim;Fx &there4; &sim;(x)Fx."
</ol>

Here's the general strategy:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>START<br>
&nbsp;&nbsp;S&I + new quantificational rules&nbsp;&nbsp;<br>
RAA<br>
ASSUME<br>
REFUTE</td></tr></table></center><br>

Here's a quantificational proof:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;*&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(&exist;x)(Fx &#8226; Gx)&nbsp;&nbsp;&nbsp;&nbsp;Valid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;(&exist;x)Fx<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&#9484;&nbsp;asm: &sim;(&exist;x)Fx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&#9474;&nbsp;&there4;&nbsp;(x)&sim;Fx&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;&there4;&nbsp;(Fa &#8226; Ga)&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9474;&nbsp;&there4;&nbsp;&sim;Fa&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&#9492;&nbsp;&there4;&nbsp;Fa&nbsp;&nbsp;{from 4}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&there4;&nbsp;(&exist;x)Fx&nbsp;&nbsp;{from 2; 5 contradicts 6}&nbsp;&nbsp;</td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 2). We use the reverse-squiggle rules on 2 to get 3, drop "(&exist;x)" in 1 using a new letter "a" to get 4, and drop "(x)" in 3 using the old letter "a" to get 5. We derive line 6 using the S- and I-rules. Finally, we apply RAA to complete the proof (line 7).<br><br>

<center><font size="5">Invalid Arguments</font></center><br>

If we attempt to prove an invalid argument, we'll instead be led to a <b>refutation</b> &ndash; a little possible world with various individuals (like <b>a</b> and <b>b</b>) and various simple truths about these individuals (like <b>Fa</b> and <b>&sim;Fb</b>) &ndash; a possible world that would make premises all true and conclusion false. Evaluate each wff that starts with a quantifier as follows:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>A <b>universal wff</b> is true if and only if<br><b>all cases</b> are true.</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;An <b>existential wff</b> is true if and only if&nbsp;&nbsp;<br><b>at least one case</b> is true.</center></td></tr>
</table></center><br>

As before, be sure to check that your refutation works. If you don't get premises all 1 and conclusion 0, then you did something wrong &ndash; and you should check out what you did with the formula that didn't come out right.<br><br>
Here's an invalid quantificational argument:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(x)(Fx &sup; Gx)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;(&exist;x)Fx&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;(x)Gx&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;asm: &sim;(x)Gx<br>
&nbsp;&nbsp;*&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;(&exist;x)&sim;Gx&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&sim;Ga&nbsp;&nbsp;{from 4}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;Fb&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;(Fa &sup; Ga)&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;(Fb &sup; Gb)&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&sim;Fa&nbsp;&nbsp;{from 5 and 7}&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;Gb&nbsp;&nbsp;{from 6 and 8}</td><td nowrap bordercolor=#000000  bgcolor=#FFFF88><center>
Invalid<br>
a, b<br><br>
&nbsp;&nbsp;&sim;Fa, &sim;Ga&nbsp;&nbsp;<br>
Fb, Gb</center></td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 3). We first reverse squiggles (line 4). We drop each "(&exist;x)" with a new letter, using "a" the first time and "b" the second (lines 5 and 6). We drop the "(x)" from line 1 once for each old letter (lines 7 and 8). We derive a few more things using the S- and I-rules (lines 9 and 10). Since we get no contradiction, we instead collect the simple wffs to get a refutation, as on the right above. Our little world has two entities, <b>a</b> and <b>b</b>. In this world, the first premise <nobr>"(x)(Fx &sup; Gx)"</nobr> is true, since each instance is true:<br><br>
<center>
(Fa &sup; Ga)&nbsp;&nbsp;=&nbsp;&nbsp;(0 &sup; 0)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
(Fb &sup; Gb)&nbsp;&nbsp;=&nbsp;&nbsp;(1 &sup; 1)&nbsp;&nbsp;=&nbsp;&nbsp;1</center><br>
The second premise "(&exist;x)Fx" is true, since at least one instance is true (namely "Fb"). The conclusion "(x)Gx" is false, since at least one instance is false (since "Ga" is false). Since our refutation makes premises all true and conclusion false, the argument is shown to be invalid.<br><br>

<center><font size="5">Harder Arguments</font></center><br>

Proofs using multiple or non-initial quantifiers follow the same inference rules as before but often are less mechanical and require multiple assumptions. Remember to drop only initial quantifiers; so we should treat a wff like <nobr>"((x)Fx &sup; (x)Gx)"</nobr> as an if-then, and use only the propositional rules on it (including making another assumption if needed). Here's an example:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;((x)Fx &sup; (x)Gx)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;(Fa &sup; Ga)&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;asm: &sim;(Fa &sup; Ga)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;Fa&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&sim;Ga&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asm:&nbsp;&sim;(x)Fx&nbsp;&nbsp;{break 1}&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;**&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;(&exist;x)&sim;Fx&nbsp;&nbsp;{from 5}<br>
&nbsp;&nbsp;&nbsp;**&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&sim;Fb&nbsp;&nbsp;{from 6}</td><td nowrap bordercolor=#000000  bgcolor=#FFFF88><center>
Invalid<br>
a,b<br><br>
&nbsp;&nbsp;Fa, &sim;Ga&nbsp;&nbsp;<br>
&sim;Fb</center></td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 2). We apply an S-rule to the assumption (lines 3 and 4). Since we're stuck, we make another assumption (line 5). We reverse squiggles (line 6) and drop the "(&exist;x)" with the new letter "b" (line 7). Since we get no contradiction, we instead collect the simple wffs to get a refutation, as on the right above. This little world has two entities, <b>a</b> and <b>b</b>. In evaluating a wff like "((x)Fx&nbsp;&sup;&nbsp;(x)Gx)," evaluate each part starting with a quantifier separately and then put the pieces together. So:<br><br>
<center>
"(x)Fx" is false, since "Fb" is false<br>
"(x)Gx" is false, since "Ga" is false<br>
So "((x)Fx &sup; (x)Gx)"&nbsp;&nbsp;=&nbsp;&nbsp;(0 &sup; 0)&nbsp;&nbsp;=&nbsp;&nbsp;1
</center><br>
So the first premise is true. The conclusion is false, since the first part is true and the second false. Since our refutation makes premises all true and conclusion false, the argument is shown to be invalid.<br><br>

<center><font size="5">Identity Arguments</font></center><br>

Identity logic adds two new inference rules:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Self-identity&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;a=a&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Equals may substitute for equals&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;a=b,&nbsp;Fa&nbsp;&nbsp;&#8658;&nbsp;&nbsp;Fb&nbsp;&nbsp;</center></td></tr>
</table></center><br>

In the first rule, any constant can substitute for "a"; you can add a self-identity anywhere, regardless of earlier lines. Adding "a=a" can be useful if this gives us a contradiction (in case we already have "&sim;a=a") or lets us apply an I-rule (in case we already have something like <nobr>"(a=a&nbsp;&sup;&nbsp;Gb)").</nobr> In the second rule, any constants can replace "a" and "b" and any wffs can replace "Fa" and "Fb" &ndash; provided that the two wffs are alike except that the two constants are switched in one or more occurrences. Here's an identity proof:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;*&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(&exist;x)(&exist;y)&sim;x=y&nbsp;&nbsp;&nbsp;&nbsp;Valid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&sim;(&exist;x)(y)y=x<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&#9484;&nbsp;asm: (&exist;x)(y)y=x<br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&#9474;&nbsp;&there4;&nbsp;(&exist;y)&sim;a=y&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;&there4;&nbsp;&sim;a=b&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9474;&nbsp;&there4;&nbsp;(y)y=c&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&#9474;&nbsp;&there4;&nbsp;a=c&nbsp;&nbsp;{from 5}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&#9474;&nbsp;&there4;&nbsp;b=c&nbsp;&nbsp;{from 5}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&#9492;&nbsp;&there4;&nbsp;a=b&nbsp;&nbsp;{from 6 and 7}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&there4;&nbsp;&sim;(&exist;x)(y)y=x&nbsp;&nbsp;{from 2; 4 contradicts 8}&nbsp;&nbsp;</td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 2). We drop each initial "(&exist;x)" with a new letter, using "a" and then "b" and then "c" (lines 3 to 5). We drop the "(y)" in line 5 once for each old letter (lines 6 and 7) &ndash; except "c," which won't help us. We then take 6 and replace "c" with "b," which 7 claims to be identical (line 8). Finally, we apply RAA to complete the proof (line 9).<br><br>

<center><font size="5">Relational Arguments</font></center><br>

<b>Relational proofs</b> follow the same inference rules but bring in some new wrinkles.
Relational formulas often use back-to-back quantifiers &ndash; as in <nobr>"(x)(y)(Lxy&nbsp;&sup;&nbsp;Lyx)."</nobr> Since we can drop only an initial quantifier, we have to drop these one at a time, working from the outside. If we have several constants at this point, it may be impractical to drop each universal quantifier using all old constants; so we'll often deviate from our normal proof strategy and just plug in the constants most likely to help us to prove or refute the argument.
<br><br>
Also, our proof strategy sometimes leads into an endless loop. When you see this coming, stop the proof and figure out a refutation. Here's an example:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x)(&exist;y)Lxy&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4;&nbsp;(&exist;y)(x)Lxy&nbsp;&nbsp;</td><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Everyone loves someone or other.<br>
&nbsp;&nbsp;&there4;&nbsp;There is someone that everyone loves.&nbsp;&nbsp;</td></tr>
</table></center><br>

Here's what happens when we apply our proof strategy mechanically to the first premise:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x)(&exist;y)Lxy&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4;&nbsp;(&exist;y)Lay<br>
&nbsp;&nbsp;&there4;&nbsp;Lab<br>
&nbsp;&nbsp;&there4;&nbsp;(&exist;y)Lby<br>
&nbsp;&nbsp;&there4;&nbsp;Lbc<br>
&nbsp;&nbsp;&there4;&nbsp;(&exist;y)Lcy&nbsp;&nbsp;...&nbsp;&nbsp;</td><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Everyone loves someone or other.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4;&nbsp;a loves someone or other.<br>
&nbsp;&nbsp;&there4;&nbsp;a loves b.<br>
&nbsp;&nbsp;&there4;&nbsp;b loves someone or other.<br>
&nbsp;&nbsp;&there4;&nbsp;b loves c.<br>
&nbsp;&nbsp;&there4;&nbsp;c loves someone or other.&nbsp;&nbsp;...</td></tr>
</table></center><br>

You can usually stop before introducing your third constant. You have to figure out the refutation for yourself; try using the formulas that you've derived that contain the first two constants &ndash; and then add any further formulas that you need to make premises all true and conclusion false. This refutation works for our example:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x)(&exist;y)Lxy&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4;&nbsp;(&exist;y)(x)Lxy&nbsp;&nbsp;=&nbsp;&nbsp;0&nbsp;&nbsp;<br><br><br><br></td><td nowrap><center>
Invalid<br>
a,b<br><br>
Lab, Lba<br>
&nbsp;&nbsp;&sim;Laa, &sim;Lbb&nbsp;&nbsp;</center></td></tr></table></center><br>

In this little world, everyone loves someone or other (since <b>a</b> loves someone and <b>b</b> loves someone) &ndash; but it is false that there is someone that everyone loves (since not everyone loves <b>a</b> and not everyone loves <b>b</b>). Since our refutation makes premises all true and conclusion false, the argument is shown to be invalid.<br><br>
Here's a relational proof:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(x)(y)Lxy&nbsp;&nbsp;&nbsp;&nbsp;Valid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;(&exist;x)Lax<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&#9484;&nbsp;asm: &sim;(&exist;x)Lax<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&#9474;&nbsp;&there4;&nbsp;(x)&sim;Lax&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;&there4;&nbsp;&sim;Laa&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9474;&nbsp;&there4;&nbsp;(y)Lay&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&#9492;&nbsp;&there4;&nbsp;Laa&nbsp;&nbsp;{from 5}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&there4;&nbsp;(&exist;x)Lax&nbsp;&nbsp;{from 2; 4 contradicts 6}&nbsp;&nbsp;</td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 2). We reverse squiggles (line 3). We keep dropping initial universal quantifiers using the old letter "a" (lines 4 to 6). Finally, we apply RAA to complete the proof (line 7).<br>

<br><A name="J"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set J - Modal Translations</font><br><br>
<font size="5">Basic Translations</font></center><br>

<b>Modal logic</b> studies arguments whose validity depends on "necessary," "possible," and similar notions. It builds on propositional logic and thus includes all the vocabulary, wffs, inference rules, and proofs of the latter. In the next section, we'll add the machinery of quantificational logic.<br><br>
Modal logic adds two new vocabulary items: "&#9674;" and "&#9744;." We have one new way to form wffs, in addition to those used in PC:
<ul>
<li>The result of writing "&#9674;" or "&#9744;," and then a wff, is a wff.
</ul>
Compare these three:<br><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88 rules=rows><tr>
<td nowrap><center>&nbsp;&nbsp;&#9674;A&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp;It's possible that A&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp;A is true in some possible world&nbsp;&nbsp;</center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;A&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp;It's true that A&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp;A is true in the actual world&nbsp;&nbsp;</center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;&#9744;A&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp;It's necessary that A&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp;A is true in all possible worlds&nbsp;&nbsp;</center></td></tr>
</table></center><br>
	
Calling something possible is a weak claim &ndash; weaker than calling it true. Calling something necessary is a strong claim; it says, not just that the thing is true, but that it has to be true &ndash; it couldn't be false.<br><br>
"Possible" here means logically possible (not self-contradictory). "I run a mile in two minutes" may be physically impossible; but there's no self-contradiction in the idea, so it's logically possible. Likewise, "necessary" means logically necessary (self-contradictory to deny). "2+2=4" and "If there's rain, then there's precipitation" are logically necessary; such truths are based on logic, the meaning of concepts, or necessary connections between properties.<br><br>
We can paraphrase "possible" as true in some possible world &ndash; and "necessary" as true in all possible worlds. A <b>possible world</b> is a consistent and complete description of how things might have been or might in fact be. Picture a possible world as a consistent story (or novel). The story is consistent, in that its statements don't entail self-contradictions; the story describes a set of possible situations that are all possible together. The story is complete, in that every possible fact or its denial is included. The story may or may not be true. The actual world is the story that's true &ndash; the description of how things in fact are.<br><br>
Here are some common modal translations:<br><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88 rules=rows><tr>
<td nowrap><center>&nbsp;&nbsp;A is possible (consistent, could be true)&nbsp;&nbsp;<br>=&nbsp;&nbsp;&#9674;A</center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;A is necessary (must be true, has to be true)&nbsp;&nbsp;<br>=&nbsp;&nbsp;&#9744;A</center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;A is impossible (self-contradictory, can't be true, must be false)&nbsp;&nbsp;<br>=&nbsp;&nbsp;&sim;&#9674;A&nbsp;&nbsp;=&nbsp;&nbsp;&#9744;&sim;A</center></td></tr>
</table></center><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88 rules=rows><tr>
<td nowrap><center>&nbsp;&nbsp;A is consistent (compatible) with B&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp;&#9674;(A &#8226; B)&nbsp;&nbsp;</center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;A entails B&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp; &#9744;(A &sup; B)&nbsp;&nbsp; </center></td></tr>
</table></center><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88 rules=rows><tr>
<td nowrap><center>&nbsp;&nbsp;A is a contingent statement&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp;(&#9674;A &#8226; &#9674;&sim;A)&nbsp;&nbsp;</center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;A is a contingent truth&nbsp;&nbsp;</center></td><td nowrap>=</td>
<td nowrap><center>&nbsp;&nbsp; (A &#8226; &#9674;&sim;A)&nbsp;&nbsp; </center></td></tr>
</table></center><br>

Mimic the English when you translate:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;not necessary&nbsp;&nbsp;=&nbsp;&nbsp;&sim;&#9744;&nbsp;&nbsp;<br>&nbsp;&nbsp;necessary not&nbsp;&nbsp;=&nbsp;&nbsp;&#9744;&sim;&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;necessary if&nbsp;&nbsp;=&nbsp;&nbsp;&#9744;(&nbsp;&nbsp;<br>&nbsp;&nbsp;if necessary&nbsp;&nbsp;=&nbsp;&nbsp;(&#9744;&nbsp;&nbsp;</center></td></tr></table></center><br>

Use a separate box or diamond for each "necessary" or "possible":<br><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88 rules=rows><tr>
<td nowrap><center>&nbsp;&nbsp;If A is necessary and B is possible, then C is possible&nbsp;&nbsp;<br>=&nbsp;&nbsp;((&#9744;A &#8226; &#9674;B) &sup; &#9674;C)</center></td></tr>
</table></center><br>

When you see these next forms, say that they are ambiguous and translate them two ways (as both box-inside and box-outside formulas):<br><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88 rules=rows><tr>
<td nowrap><center>&nbsp;&nbsp;If A is true, then it's necessary (must be) that B&nbsp;&nbsp;<br>could mean "(A &sup; &#9744;B)" or "&#9744;(A &sup; B)"</center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;If A is true, then it's impossible (couldn't be) that B&nbsp;&nbsp;<br>could mean "(A &sup; &#9744;&sim;B)" or "&#9744;(A &sup; &sim;B)"</center></td></tr>
</table></center><br>

For example, this sentence could have either of the following two meanings: <i>"If you're a bachelor, then you must be unmarried."</i>
<ol>
<li>(B &sup; &#9744;U)&nbsp;&nbsp;=&nbsp;&nbsp;If B, then U (by itself) is necessary&nbsp;&nbsp;=&nbsp;&nbsp;If you're a bachelor, then you're inherently unmarriable &ndash; in no possible world would anyone ever marry you. (This is insulting and presumably false.)
<li>&#9744;(B &sup; U)&nbsp;&nbsp;=&nbsp;&nbsp;It's necessary that if B then U&nbsp;&nbsp;=&nbsp;&nbsp;It's necessary that if you're a bachelor then you're unmarried. (This is trivially true because we use "bachelor" to mean unmarried man.)
</ol>
The ambiguous forms are IF-THENs with a strong modal term (like "necessary," "must," "impossible," or "can't") in the THEN part. It's not ambiguous if you say that the second part "by itself" is necessary or impossible &ndash; or if you use "entails" or start with "necessarily" or "it's necessary that."<br><br>

<center><font size="5">Quantified Translations</font></center><br>

<b>Quantified Modal Logic</b> adds quantificational logic (its vocabulary, wffs, inference rules, and proofs) to modal logic. Here are some translations:<br><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88 rules=rows><tr>
<td nowrap><center>&nbsp;&nbsp;It's possible for everyone to be above average&nbsp;&nbsp;<br>=&nbsp;&nbsp;&#9674;(x)Ax</center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;It's possible for anyone to be above average&nbsp;&nbsp;<br>=&nbsp;&nbsp;(x)&#9674;Ax</center></td></tr>
</table></center><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88 rules=rows><tr>
<td nowrap><center>&nbsp;&nbsp;F is a necessary (essential) property of x&nbsp;&nbsp;<br>
=&nbsp;&nbsp;x is necessarily F<br>
=&nbsp;&nbsp;In all possible worlds, x would be F<br>
=&nbsp;&nbsp;&#9744;Fx<br></center></td></tr><tr>
<td nowrap><center>&nbsp;&nbsp;F is a contingent (accidental) property of x&nbsp;&nbsp;<br>
=&nbsp;&nbsp;x is F but could have lacked F<br>
&nbsp;&nbsp;=&nbsp;&nbsp;x is F in the actual world but isn't F in some possible world&nbsp;&nbsp;<br>
=&nbsp;&nbsp;(Fx &#8226; &#9674;&sim;Fx)</center></td></tr>
</table></center><br>

The last two examples speak of necessary and contingent properties. Perhaps the number 8 necessarily has the property of being even &ndash; but contingently has the property of being my favorite number. And perhaps Socrates necessarily has the property of being capable of thought &ndash; but contingently has the property of having a beard.<br><br>
"All As are necessarily Bs" is ambiguous between the box-inside form <nobr>"(x)(Ax &sup; &#9744;Bx)"</nobr> and the box-outside form <nobr>"&#9744;(x)(Ax &sup; Bx)."</nobr> This sentence could have either of the following two meanings:
<i>"All persons are necessarily persons."</i>
<ol>
<li>Everyone who in fact is a person has the necessary property of being a person.<br>
=&nbsp;&nbsp;(x)(Px &sup; &#9744;Px)
<li>This is necessary: "All persons are persons."<br>
=&nbsp;&nbsp;&#9744;(x)(Px &sup; Px)
</ol>
The first is called <i>de re</i> ("of the thing") necessity, because it attributes necessity to a specific entity having a specific property. The second is called <i>de dicto</i> ("of the saying") necessity, because it attributes necessity to a whole sentence. The first form is more controversial.<br>

<br><A name="K"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set K - Modal Proofs</font><br><br>
<font size="5">Basic Proofs</font></center><br>

<b>Modal proofs</b> require that we add world prefixes and broaden our notions of derived lines, assumptions, and RAA:
<ul>
<li>A <b>world prefix</b> is a string of zero or more instances of "W." So "&nbsp;&nbsp;" (zero instances), "W," "WW," and so on are world prefixes. These represent possible worlds, with the blank world prefix ("&nbsp;&nbsp;") representing the actual world.
<li>Modal logic's <b>derived</b> lines consist of <i>a world prefix and then</i> "&there4;" and then a wff (like "W &there4; A" &ndash; "Therefore A is true in world W"). Modal logic's <b>assumptions</b> consist of a world prefix and then "asm:" and then a wff (like "W asm: A" &ndash; "Assume that A is true in world W"). Unless otherwise specified, we can use an inference rule only within a given world.
<li><b>RAA</b>: Suppose that some pair of not-blocked-off lines <i>using the same world prefix</i> have contradictory wffs. Then block off all the lines from the last not-blocked-off assumption on down and infer a line consisting in <i>this assumption's world prefix followed by</i> "&there4;" followed by a contradictory of that assumption.
</ul>
Modal proofs use four new inference rules (where any pair of contradictory wffs can replace "A" / "&sim;A" and any world prefix can replace "W"):<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Reverse squiggles&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;&sim;&#9744;A&nbsp;&nbsp;&#8658;&nbsp;&nbsp;&#9674;&sim;A&nbsp;&nbsp;<br>&nbsp;&nbsp;&sim;&#9674;A&nbsp;&nbsp;&#8658;&nbsp;&nbsp;&#9744;&sim;A&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Drop diamonds&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;&#9674;A&nbsp;&nbsp;&#8658;&nbsp;&nbsp;W &there4; A,&nbsp;&nbsp;<br>&nbsp;&nbsp;use a <b>new</b> string of W's&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Drop boxes&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;&#9744;A&nbsp;&nbsp;&#8658;&nbsp;&nbsp;W &there4; A,&nbsp;&nbsp;<br>&nbsp;&nbsp;use any world prefix&nbsp;&nbsp;</center></td></tr>
</table></center><br>

A world prefix is <b>old</b> if it already occurs in the argument; otherwise it's <b>new</b>.<br><br>
Our proof strategy still uses START, S&I, RAA, ASSUME and REFUTE. It adds these to the S&I part:
<ol>
<li><b>First reverse squiggles</b>: For each unstarred, not-blocked-off line that begins with "&sim;" and then a box or diamond, derive a line using the reverse-squiggle rules. Star the original line.
<li><b>And drop diamonds</b>: For each unstarred, not-blocked-off line that begins with a diamond, derive an instance using the next available <i>new</i> world prefix (unless some such instance already occurs in previous lines). Star the original line.
<li><b>Lastly drop boxes</b>: For each not-blocked-off line that begins with a box, derive instances using each <i>old</i> world. Don't star the original line; you might have to use it again. Note: Drop a box into the actual world just if (a) the premises or conclusion have an unmodalized instance of a letter, or (b) you've done everything else (including further assumptions if needed) and still have no other worlds.
</ol>

Here's the general strategy:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>START<br>
&nbsp;&nbsp;S&I + new modal rules&nbsp;&nbsp;<br>
RAA<br>
ASSUME<br>
REFUTE</td></tr></table></center><br>

Here's a modal proof:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&#9744;(A &#8226; B)&nbsp;&nbsp;&nbsp;&nbsp;Valid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&#9744;A<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&#9484;&nbsp;asm: &sim;&#9744;A<br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&#9474;&nbsp;&there4;&nbsp;&#9674;&sim;A&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;W&nbsp;&there4;&nbsp;&sim;A&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9474;&nbsp;W&nbsp;&there4;&nbsp;(A &#8226; B)&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&#9492;&nbsp;W&nbsp;&there4;&nbsp;A&nbsp;&nbsp;{from 5}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&there4;&nbsp;&#9744;A&nbsp;&nbsp;{from 2; 4 contradicts 6}&nbsp;&nbsp;</td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 2). We use the reverse-squiggle rules on 2 to get 3, drop "&#9674;" in 3 using a new world "W" to get 4, and drop "&#9744;" in 1 using the old world "W" to get 5. We derive line 6 using an S-rules. Finally, we apply RAA to complete the proof (line 7).<br><br>

<center><font size="5">Invalid Arguments</font></center><br>

If we attempt to prove an invalid modal argument, we'll instead be led to an <b>modal refutation</b> &ndash; a galaxy of possible worlds that would make premises all true and conclusion false. Each world in the galaxy assigns "1" or "0" to the letters. Evaluate each wff as follows:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>"&#9744;A" is true if and only if "A" is true in all worlds.</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;"&#9674;A" is true if and only if "A" is true in at least one world.&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>"A" is true if and only if "A" is true in the actual world.</center></td></tr>
</table></center><br>

As before, be sure to check that your attempted refutation works &ndash; that you get premises 1 and conclusion 0. If a line comes out wrong, then you did something wrong with it &ndash; either deriving something wrongly or else not deriving something that you should have derived.<br><br>
Here's an invalid modal argument:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&#9744;(A &sup; B)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&#9674;A&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&#9744;B&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;asm: &sim;&#9744;B<br>
&nbsp;&nbsp;*&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&#9674;&sim;B&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&there4;&nbsp;A&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;WW&nbsp;&there4;&nbsp;&sim;B&nbsp;&nbsp;{from 4}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&there4;&nbsp;(A &sup; B)&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;WW&nbsp;&there4;&nbsp;(A &sup; B)&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&there4;&nbsp;B&nbsp;&nbsp;{from 5 and 7}&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;WW&nbsp;&there4;&nbsp;&sim;A&nbsp;&nbsp;{from 6 and 8}&nbsp;&nbsp;</td><td nowrap bordercolor=#000000  bgcolor=#FFFF88><center>
Invalid<br><br>
&nbsp;&nbsp;W:&nbsp;&nbsp;&sim;A, &sim;B&nbsp;&nbsp;<br>
&nbsp;&nbsp;WW:&nbsp;&nbsp;A, B&nbsp;&nbsp;</center></td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 3). We reverse squiggles (line 4). We drop each diamond into a new world, using "W" the first time and "WW" the second (lines 5 and 6). We drop the box from line 1 into each old world (lines 7 and 8). We derive a few more things using the I-rules (lines 9 and 10). Since we get no contradiction, we instead collect the simple wffs to get a refutation, as on the right above. Our little galaxy has two possible worlds, W and WW. In this galaxy, the first premise "&#9744;(A &sup; B)" is true, since "(A &sup; B)" is true in both worlds:<br><br>
<center>
In world W:&nbsp;&nbsp;(A &sup; B)&nbsp;&nbsp;=&nbsp;&nbsp;(0 &sup; 0)&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
In world WW:&nbsp;&nbsp;(A &sup; B)&nbsp;&nbsp;=&nbsp;&nbsp;(1 &sup; 1)&nbsp;&nbsp;=&nbsp;&nbsp;1</center><br>
The second premise "&#9674;A" is true, since "A" is true in at least one world (namely world WW). The conclusion "&#9744;B" is false, since "B" is false in at least one world (namely world W). Since our refutation makes premises all true and conclusion false, the argument is shown to be invalid.<br><br>

<center><font size="5">Galactic Travel</font></center><br>

Logicians differ on the validity of some arguments (like "&#9674;&#9674;A &there4; &#9674;A") in which one modal operator occurs within the scope of another. These disputes reflect differences in how to formulate the box-dropping rule. So far, we've been assuming a system called "<b>S5</b>," which lets us go from any world to any other world when we drop a box:
<blockquote>
<b>Drop boxes</b>:&nbsp;&nbsp;If we have a "&#9744;A" line, we can derive a "A" line. We can use any world prefixes (the same or different) in either line.
</blockquote>
This assumes that whatever is necessary in any world is thereby true in all worlds without restriction. A further implication is that whatever is necessary in one world is thereby necessary in all worlds.<br><br>
Some weaker views reject these ideas. On these views, what is necessary only has to be true in all "suitably related" worlds; these views qualify the drop-box rule. So we can't always go from "&#9744;A" in one world to "A" in another world; traveling between worlds requires a suitable "travel ticket." (All the systems let us go from "&#9744;A" in a world to "A" in that same world.)<br><br>
We get travel tickets when we drop diamonds. Let "W1" and "W2" stand for world prefixes. Suppose we go from "&#9674;A" in world W1 to "A" in a new world W2. Then we get a travel ticket from W1 to W2; we'll symbolize this by writing "W1 &#8658; W2." Suppose we are doing a proof with the formulas "&#9674;&#9674;P" and "&#9674;Q"; then we could derive these lines and travel tickets (where "#" stands for the actual world):<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&#9674;&#9674;P<br>
&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&#9674;Q<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&there4;&nbsp;&#9674;P&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;WW&nbsp;&there4;&nbsp;P&nbsp;&nbsp;{from 11}<br>
&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;WWW&nbsp;&there4;&nbsp;Q&nbsp;&nbsp;{from 2}&nbsp;&nbsp;</td><td nowrap bordercolor=#000000  bgcolor=#FFFF88><center><br>
&nbsp;&nbsp;<b>Travel Tickets</b>&nbsp;&nbsp;<br><br>
#&nbsp;&nbsp;&#8658;&nbsp;&nbsp;W<br>
W&nbsp;&nbsp;&#8658;&nbsp;&nbsp;WW<br>
#&nbsp;&nbsp;&#8658;&nbsp;&nbsp;WWW</center></td></tr></table></center><br>

Tickets are reusable; we can use "W1&nbsp;&nbsp;&#8658;&nbsp;&nbsp;W2" any number of times. The rules for using tickets vary. Some systems let us combine tickets or use them in both direction; but system T lets us use only one ticket at a time &ndash; and only in the direction of the arrow. Suppose that we have "&#9744;A" in world W1 and want to put "A" in world W2:

<ul>
<li><b>System T</b>: We need a <i>ticket</i> from W1 to W2.
<li><b>System S4</b>: Like T, but we also can use a <i>series</i> of tickets.
<li><b>System B</b>: Like T, but a ticket also works <i>backwards</i>.
<li><b>System S5</b>: We can go between worlds without restriction (no tickets needed).
</ul>
In our example, <b>T</b> lets us go from # to W, from W to WW, and from # to WWW. The other systems allow these and more. <b>S4</b> lets us use a series of tickets in the direction of the arrow; this lets us go from # to WW. <b>B</b> lets us use single tickets in either direction; so we also can go from W to #, from WW to W, and from WWW to #. <b>S5</b> lets us go from any world to any other world.<br><br>
<b>S5</b> is the most liberal and accepts the greatest number of valid arguments. <b>T</b> is the weakest system, allowing the fewest proofs. In practice, however, only a few arguments are valid in one system but invalid in another; these all involve wffs that apply a modal operator to a wff already containing a modal operator. Here's an argument where the difference is important:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&#9744;A<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&#9744;&#9744;A<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&#9484;&nbsp;asm: &sim;&#9744;&#9744;A<br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&#9474;&nbsp;&there4;&nbsp;&#9674;&sim;&#9744;A&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;W&nbsp;&there4;&nbsp;&sim;&#9744;A&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;5&nbsp;&#9474;&nbsp;W&nbsp;&there4;&nbsp;&#9674;&sim;A&nbsp;&nbsp;{from 4}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&#9474;&nbsp;WW&nbsp;&there4;&nbsp;&sim;A&nbsp;&nbsp;{from 5}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&#9492;&nbsp;WW&nbsp;&there4;&nbsp;A&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&there4;&nbsp;&#9744;&#9744;A&nbsp;&nbsp;{from 2; 6 contradicts 7}&nbsp;&nbsp;</td><td nowrap bordercolor=#000000  bgcolor=#FFFF88>
<center>&nbsp;&nbsp;Valid in S4&nbsp;&nbsp;<br>and S5<br><br><br>
#&nbsp;&nbsp;&#8658;&nbsp;&nbsp;W<br><br>
&nbsp;&nbsp;W&nbsp;&nbsp;&#8658;&nbsp;&nbsp;WW&nbsp;&nbsp;</center><br><br>
</tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 2). We reverse squiggles and drop diamonds (lines 3 to 6). Along the way, we get two travel ticket: from # to W &ndash; and from W to WW. Line 7, in which we go from "&#9744;A" in world # to "A" in world WW, requires that we combine a series of tickets in the direction of the arrow &ndash; which requires systems <b>S4</b> or <b>S5</b>. Finally, we apply RAA to complete the proof (line 8).<br><br>

<center><font size="5">Quantified Modal Arguments</font></center><br>

There are two main approaches to <b>quantified modal logic</b>. The <b>naive approach</b> just combines the standard proof systems for modal and quantificational logic. This approach isn't entirely satisfactory, since it leads to certain things being provable that shouldn't be provable; the <b>sophisticated approach</b> (which is discussed in the book) modifies some inference rules to avoid the problems. LogiCola keeps to the naive approach.<br><br>
Here's a quantified modal argument:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(x)&#9674;Ax&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&#9674;(x)Ax&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;asm: &sim;&#9674;(x)Ax<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&#9744;&sim;(x)Ax&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&#9674;Aa&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&there4;&nbsp;Aa&nbsp;&nbsp;{from 4}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&there4;&nbsp;&sim;(x)Ax&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&there4;&nbsp;(&exist;x)&sim;Ax&nbsp;&nbsp;{from 6}&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&there4;&nbsp;&sim;Ab&nbsp;&nbsp;{from 7}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&#9674;Ab&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;WW&nbsp;&there4;&nbsp;Ab&nbsp;&nbsp;{from 9}<br>
&nbsp;&nbsp;*&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;WW&nbsp;&there4;&nbsp;&sim;(x)Ax&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;*&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;WW&nbsp;&there4;&nbsp;(&exist;x)&sim;Ax&nbsp;&nbsp;{from 6}&nbsp;&nbsp;</td><td nowrap bordercolor=#000000  bgcolor=#FFFF88><center>
Invalid<br>a, b<br><br>
W:&nbsp;&nbsp;Aa, &sim;Ab<br>
&nbsp;&nbsp;WW:&nbsp;&nbsp;Ab, &sim;Aa&nbsp;&nbsp;</center></td></tr></table></center><br>

Applying the standard strategy leads us into an endless loop, where we keep getting new letters (lines 4, 8, 13, and every five lines thereafter) and new worlds (lines 5, 10, 15, and every five lines thereafter), endlessly. So we have to break out of the loop and figure out a refutation for ourselves. A good strategy is to try using the formulas that we've derived that contain the first two constants &ndash; and then add any further formulas that we need to make premises all true and conclusion false. The refutation on the right side works for our example. We can think of our argument as saying this:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x)&#9674;Ax&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4;&nbsp;&#9674;(x)Ax&nbsp;&nbsp;=&nbsp;&nbsp;0&nbsp;&nbsp;</td><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It's possible for anyone to be above average.<br>
&nbsp;&nbsp;&there4;&nbsp;It's possible for everyone to be above average.&nbsp;&nbsp;</td></tr></table></center><br>

Here each person is above average in some world or other &ndash; but in no world is every person above average. Since our refutation makes premises all true and conclusion false, the argument is shown to be invalid.<br>

<br><A name="L"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set L - Deontic Translations</font></center><br>
<center><font size="5">Imperative Translations</font></center><br>
<b>Imperative logic</b> studies arguments with imperatives, like "Do this."
<b>Deontic logic</b>, by contrast, studies arguments whose validity depends on "ought," "permissible," and similar notions.
We'll take imperative logic first and then build deontic logic on it.<br><br>
Imperative logic builds on our previous systems (propositional, quantificational, and modal logic); it adds underlining ("_") to form imperative wffs:
<ol>
<li>Any underlined capital letter is an imperative wff.
<li>The result of writing a capital letter and then one or more small letters, one small letter of which is underlined, is an imperative wff.
</ol>
Compare these forms:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr>
<td nowrap><center>&nbsp;&nbsp;<b>Indicative</b>&nbsp;&nbsp;<br>&nbsp;&nbsp;You're doing A&nbsp;&nbsp;<br><br>A<br>Au</center></td>
<td nowrap><center>&nbsp;&nbsp;<b>Imperative</b>&nbsp;&nbsp;<br>Do A<br><br><u>A</u><br>A<u>u</u>
</center></td></tr></table></center><br>

Here are some further translations:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&sim;<u>A</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Don't do A.</div></tr><tr><td nowrap>
<div align="right">(<u>A</u> &#8226; <u>B</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Do A and B.</td></tr><tr><td nowrap>
<div align="right">&sim;(<u>A</u> &#8226; <u>B</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Don't both do A and do B.<br>Don't combine doing A with doing B.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;&sim;(<u>A</u> &#8226; &sim;<u>B</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Don't combine doing A with not doing B.&nbsp;&nbsp;<br>Don't do A without doing B.</td></tr></table></center><br>

Underline imperative parts but not factual ones:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">(A &#8226; B)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You're doing A and you're doing B.&nbsp;&nbsp;</div></tr><tr><td nowrap>
<div align="right">(A &#8226; <u>B</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You're doing A, but do B.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(<u>A</u> &#8226; <u>B</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Do A and B.</td></tr></table></center><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">(A &sup; B)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
If you're doing A, then you're doing B.&nbsp;&nbsp;</div></tr><tr><td nowrap>
<div align="right">(A &sup; <u>B</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
If you (in fact) are doing A, then do B.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(<u>A</u> &sup; B)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Do A, only if you (in fact) are doing B.</td></tr></table></center><br>

There's a subtle difference between the following two forms; the first tells you exactly what to do under specified circumstances &ndash; and the second tells you to avoid a certain combination of actions:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">(A &sup; &sim;<u>B</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
If you (in fact) are doing A, then don't do B.&nbsp;&nbsp;</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;&sim;(<u>A</u> &#8226; &sim;<u>B</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Don't combine doing A with not doing B.&nbsp;&nbsp;</td></tr></table></center><br>

These examples build on quantificational logic and underline the letter for the agent:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">A<u>x</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
X, do (or be) A.<br>Let it be the case that X does A.<br>Would that X do A.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;A<u>x</u>y</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
X, do A to Y.<br>Let it be the case that X does A to Y.&nbsp;&nbsp;<br>Would that X do A to Y.</td></tr></table></center><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">(x)A<u>x</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Let everyone do A.&nbsp;&nbsp;</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(&exist;x)A<u>x</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Let someone do A.</td></tr></table></center><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">(x)(Ax &sup; B<u>x</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Let everyone who (in fact) is doing A do B.&nbsp;&nbsp;</td></tr><tr><td nowrap>
<div align="right">(&exist;x)(Ax &#8226; B<u>x</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Let someone who (in fact) is doing A do B.&nbsp;&nbsp;</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(&exist;x)(A<u>x</u> &#8226; B<u>x</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Let someone both do A and do B.</td></tr></table></center><br>

<center><font size="5">Deontic Translations</font></center><br>

Deontic logic studies arguments whose validity depends on "ought," "permissible," and similar notions. It builds on our previous systems (propositional, quantificational, and modal logic) and also on imperative logic. It adds two new symbols, "O" for ought and "R" for permissible (all right) and one additional way to form wffs:
<ul>
<li>The result of writing "O" or "R," and then an imperative wff, is a deontic wff.
</ul>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;O<u>A</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
It ought to be that A.<br>Act A is obligatory (required, a duty).&nbsp;&nbsp;</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;R<u>A</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
It would be all right that A.<br>Act A is right (permissible, OK).</td></tr></table></center><br>

Here are further translations:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Act A is wrong (not right, ought not to be done)&nbsp;&nbsp;<br>
=&nbsp;&nbsp;&sim;R<u>A</u>&nbsp;&nbsp;=&nbsp;&nbsp;O&sim;<u>A</u></center></td></tr>
<tr><td nowrap><center>You ought to do A and B.<br>
=&nbsp;&nbsp;O(<u>A</u> &#8226; <u>B</u>)</center></td></tr>
<tr><td nowrap><center>If you do A, then you ought not to do B.<br>
=&nbsp;&nbsp;(A &sup; O&sim;<u>B</u>)</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;You ought not to combine doing A with doing B.&nbsp;&nbsp;<br>
=&nbsp;&nbsp;O&sim;(<u>A</u> &#8226; <u>B</u>)</center></td></tr></table></center><br>

These examples build on quantificational logic:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>X ought to do A.<br>
=&nbsp;&nbsp;OA<u>x</u></center></td></tr>
<tr><td nowrap><center>X ought to do A to y.<br>
=&nbsp;&nbsp;OA<u>x</u>y</center></td></tr>
<tr><td nowrap><center>It would be all right for x to do A.<br>
=&nbsp;&nbsp;RA<u>x</u></center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;It would be all right for x to do A to y.&nbsp;&nbsp;<br>
=&nbsp;&nbsp;RA<u>x</u>y</center></td></tr></table></center><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>It's obligatory that everyone do A.<br>
=&nbsp;&nbsp;O(x)A<u>x</u></center></td></tr>
<tr><td nowrap><center>It isn't obligatory that everyone do A.<br>
=&nbsp;&nbsp;&sim;O(x)A<u>x</u></center></td></tr>
<tr><td nowrap><center>It's obligatory that not everyone do A.<br>
=&nbsp;&nbsp;O&sim;(x)A<u>x</u></center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;It's obligatory that everyone refrain from doing A.&nbsp;&nbsp;<br>
=&nbsp;&nbsp;O(x)&sim;A<u>x</u></center></td></tr></table></center><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;It's obligatory that someone or other answer the phone.&nbsp;&nbsp;<br>
=&nbsp;&nbsp;O(&exist;x)A<u>x</u></center></td></tr>
<tr><td nowrap><center>There's someone (some specific person) who has an<br>obligation to answer the phone.<br>
=&nbsp;&nbsp;(&exist;x)OA<u>x</u></center></td></tr></table></center><br>

These three are importantly different:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>It's obligatory that some who kill repent.<br>
=&nbsp;&nbsp;O(&exist;x)(Kx &#8226; R<u>x</u>)</center></td></tr>
<tr><td nowrap><center>It's obligatory that some kill who repent.<br>
=&nbsp;&nbsp;O(&exist;x)(K<u>x</u> &#8226; Rx)</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;It's obligatory that some both kill and repent.&nbsp;&nbsp;<br>
=&nbsp;&nbsp;O(&exist;x)(K<u>x</u> &#8226; R<u>x</u>)</center></td></tr></table></center><br>

Here the underlined letters show which parts are obligatory: repenting, killing, or killing-and-repenting. If we just attached "O" to indicatives, our formulas couldn't distinguish the forms; all three would translate as "O(&exist;x)(Kx&nbsp;&#8226;&nbsp;Rx)." Because of such examples, we need to attach "O" to imperative wffs, not to indicative ones.<br>

<br><A name="M"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set M - Deontic Proofs</font></center><br>

<center><font size="5">Imperative Arguments</font></center><br>

<b>Imperative proofs</b> work much like indicative ones and require no new inference rules. But we must treat "A" and "<u>A</u>" as different wffs. "A" and "&sim;<u>A</u>" aren't contradictories; it's consistent to say "You're now doing A, but don't."<br><br>
Imperative logic raises questions about the meaning of "valid." This imperative argument is intuitively "valid":<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the cocoa is boiling, remove&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it from the heat.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The cocoa is boiling.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; Remove it from the heat.&nbsp;&nbsp;</td><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (B &sup; <u>R</u>)&nbsp;&nbsp;Valid&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B<br>
&nbsp;&nbsp;&there4; <u>R</u></td></tr></table></center><br>

"Valid" here can't mean that it's impossible to have true premises and a false conclusion &ndash; for imperatives aren't true-or-false. So we'll broaden what we mean by "valid argument." Henceforth a "valid argument" is an argument in which the conjunction of the premises with the contradictory of the conclusion is inconsistent; note that this definition avoids the words "true" and "false." Our argument is valid in this sense because this combination is inconsistent:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap><center>
If the cocoa is boiling, remove it<br>
&nbsp;&nbsp;from the heat. The cocoa is boiling.&nbsp;&nbsp;<br>
But don't remove it from the heat.</td></tr></table></center><br>

Here's an invalid argument with a don't-combine premise:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Don't combine accelerating&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with braking.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're accelerating.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; Don't brake.&nbsp;&nbsp;</td><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &sim;(<u>A</u> &#8226; <u>B</u>)&nbsp;&nbsp;Invalid&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A<br>
&nbsp;&nbsp;&there4; &sim;<u>B</u></td></tr></table></center><br>

The first premise forbids the accelerating-and-braking combination. If we accelerate, it doesn't follow that we shouldn't brake; maybe we need to brake and stop accelerating (perhaps to avoid a crash). It's consistent to conjoin the premises with the contradictory of the conclusion:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap><center>
Don't combine accelerating with<br>
&nbsp;&nbsp;braking. You're accelerating. But&nbsp;&nbsp;<br>
don't accelerate. Instead, brake.</td></tr></table></center><br>

Here's a refutation of the argument, put in two equivalent ways:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &sim;(<u>A</u> &#8226; <u>B</u>)&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A<br>
&nbsp;&nbsp;&there4; &sim;<u>B</u></td><td nowrap><center>
Invalid<br><br>
&nbsp;&nbsp;A, &sim;<u>A</u>, <u>B</u>&nbsp;&nbsp;</center></td><td nowrap><center>
A&nbsp;&nbsp;=&nbsp;&nbsp;1<br>
&nbsp;&nbsp;<u>A</u>&nbsp;&nbsp;=&nbsp;&nbsp;0&nbsp;&nbsp;<br>
<u>B</u>&nbsp;&nbsp;=&nbsp;&nbsp;1</tr></table></center><br>

This makes premises "1" and conclusion "0." Since imperatives aren't true-or-false, we must understand "1" and "0" more broadly; we'll now read these as "correct" and "incorrect." With indicatives, "correct" / "incorrect" mean <i>true</i> / <i>false</i>. With imperatives, these mean that the prescribed action is <i>correct </i>/ <i>incorrect</i> relative to some standard (moral or legal or whatever) that divides the actions prescribed by the imperative letters into correct and incorrect actions. In our refutation, the statement "You accelerate" is "1" (correct in the sense of true) while the imperative "Accelerate" is "0" (incorrect in the sense that the act is a bad thing to do).<br><br>
The <b>don't-combine form</b> "&sim;(<u>A</u> &#8226; <u>B</u>)" is important for imperative logic. Compare these two:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap><center>
(A &sup; &sim;<u>B</u>)<br>
&nbsp;&nbsp;If you're accelerating,&nbsp;&nbsp;<br>
then don't brake.</center></td><td nowrap><center>
&sim;(<u>A</u> &#8226; <u>B</u>)<br>
&nbsp;&nbsp;Don't combine accelerating&nbsp;&nbsp;<br>
with braking.</tr></table></center><br>

The if-then tells you exactly what to do under specified circumstances, while the don't-combine form just tells you to avoid a certain combination. Suppose that A is true (you're accelerating). The if-then tells you not to brake. The don't-combine doesn't tell you this; maybe you should instead brake and stop accelerating.<br><br>
<b>Consistency imperatives</b>, if properly formulated, use the don't-combine form. Compare these two:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap><center>
(B &sup; <u>A</u>)<br>
If you believe that<br>
&nbsp;&nbsp;you ought to do A,&nbsp;&nbsp;<br>
then do A.</center></td><td nowrap><center>
&sim;(<u>B</u> &#8226; &sim;<u>A</u>)<br>
&nbsp;&nbsp;Don't combine believing&nbsp;&nbsp;<br>
that you ought to do A<br>
with not doing A.</tr></table></center><br>
	
The if-then form can tell you to do evil things when you have malformed beliefs. The don't-combine form is better; it just forbids an inconsistent belief-action combination. If your beliefs conflict with your actions, you have to change one or the other; either may be defective.<br><br>
Here's an invalid imperative argument:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;*&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(B&#0186; &sup; <u>A</u>&#0186;)&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&sim;(<u>B</u>&#0185; &#8226; &sim;<u>A</u>&#0186;)&nbsp;&nbsp;=&nbsp;&nbsp;0<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;asm: (<u>B</u> &#8226; &sim;<u>A</u>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;<u>B</u>&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&sim;<u>A</u>&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&there4;&nbsp;&sim;B&nbsp;&nbsp;{from 1 and 4}&nbsp;&nbsp;<br></td><td nowrap bordercolor=#000000  bgcolor=#FFFF88><center>
&nbsp;&nbsp;Invalid&nbsp;&nbsp;<br><br>
&nbsp;&nbsp;&sim;B, <u>B</u>, &sim;<u>A</u>&nbsp;&nbsp;</center></td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 2). We derive all we can using the S- and I-rules (lines 3 to 5). Since we get no contradiction, we instead collect the simple wffs to get a refutation (in the right-hand box); this makes the premises "1" (true or correct) and conclusion "0" (false or incorrect). So the argument is invalid.<br><br>

<center><font size="5">Deontic Arguments</font></center><br>

<b>Deontic proofs</b> require that we broaden our notions of world prefixes and possible worlds:
<ul>
<li>A <b>world prefix</b> is now a string of zero or more instances of "W" or "D." We can use these expanded world prefixes in derived lines and assumptions, as in modal logic. "D," "DD," and so on now represent deontic worlds.
<li>We now understand a <b>possible world</b> to be a complete and consistent set of indicatives and imperatives. A deontic world is a possible world (in this expanded sense) in which (a) the indicative statements are all true, and (b) the imperatives prescribe some jointly permissible combination of actions. So then act A ought to be done ("O<u>A</u>") if and only if "Do A" is in all deontic worlds &ndash; and act A is permissible ("R<u>A</u>") if and only if "Do A" is in some deontic worlds.
</ul>
Deontic proofs add six new inference rules. In these first four, any pair of contradictory imperative wffs can replace "<u>A</u>" / "&sim;<u>A</u>":<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Reverse squiggles&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;&sim;O<u>A</u>&nbsp;&nbsp;&#8658;&nbsp;&nbsp;R&sim;<u>A</u>&emsp;<br>
&nbsp;&nbsp;&sim;R<u>A</u>&nbsp;&nbsp;&#8658;&nbsp;&nbsp;O&sim;<u>A</u>&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Drop initial R's&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;R<u>A</u>&nbsp;&nbsp;&#8658;&nbsp;&nbsp;D &there4; <u>A</u>,&nbsp;&nbsp;<br>&nbsp;&nbsp;use a <b>new</b> string of D's&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;Drop initial O's&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;O<u>A</u>&nbsp;&nbsp;&#8658;&nbsp;&nbsp;D &there4; <u>A</u>,&nbsp;&nbsp;<br>&nbsp;&nbsp;use a blank or any string of D's&nbsp;&nbsp;</center></td></tr>
</table></center><br>

In the rule about dropping R's, the world prefix of the derived line must be the same as that of the original line, except that it adds a new string (a string not occurring in earlier lines) of one or more D's at the end. In the rule about dropping O's, the world prefix of the derived line must either be the same as that of the original line or else the same except that it adds one or more D's at the end.<br><br>
These four rules work much like the earlier modal and quantificational rules. You can star the original line when you reverse squiggles or drop initial R's &ndash; but not when you drop initial O's. It's generally useful to drop O's into the actual world (going from "O<u>A</u>" to "<u>A</u>" in the same world) only if the actual world contains some imperative formulas that aren't part of a wff beginning with "O" or "R."<br><br>
The next rule, the <b>indicative transfer rule</b>, is used infrequently. The rule lets us transfer indicatives freely from a deontic world to whatever world it depends on (usually the actual world); this holds because a deontic world and whatever world it depends on have the same indicative wffs:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
D&nbsp;&nbsp;&there4;&nbsp;&nbsp;A<br>
&nbsp;&nbsp;&mdash;&mdash;&mdash;&nbsp;&nbsp;<br>
&there4;&nbsp;&nbsp;A</center></td>
<td nowrap><center>
"A" must be<br>
&nbsp;&nbsp;an indicative&nbsp;&nbsp;<br>
wff.</center></td></tr>
</table></center><br>
		
The world prefixes of the derived and deriving lines must be identical except that one ends in one or more additional D's. It can be useful to move an indicative between world D and the actual world (or vice versa) when we need it elsewhere to get a contradiction or apply an I-rule.<br><br>
The final rule, <b>Kant's Law</b>, says that "ought" entails "can" &ndash; "You ought to do A" ("OA") entails "It's possible for you to do A" ("&#9674;A"):<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
O<u>A</u><br>
&nbsp;&nbsp;&mdash;&mdash;&mdash;&nbsp;&nbsp;<br>
&there4;&nbsp;&nbsp;&#9674;A</center></td>
<td nowrap><center>
Here "A" is an imperative wff<br>
&nbsp;&nbsp;while "<u>A</u>" is the corresponding&nbsp;&nbsp;<br>
indicative wff.</center></td></tr>
</table></center><br>

Here the derived and original lines have the same world prefix. Kant's Law is often useful with arguments that contain both deontic and modal operators.<br><br>
Here's a deontic proof:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;O(x)(Ax &sup; B<u>x</u>)&nbsp;&nbsp;&nbsp;&nbsp;Valid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;Ag<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;OB<u>g</u><br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&#9484;&nbsp;asm: &sim;OB<u>g</u><br>
&nbsp;&nbsp;*&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;&there4;&nbsp;R&sim;B<u>g</u>&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9474;&nbsp;D&nbsp;&there4;&nbsp;&sim;B<u>g</u>&nbsp;&nbsp;{from 4}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&#9474;&nbsp;D&nbsp;&there4;&nbsp;(x)(Ax &sup; B<u>x</u>)&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;7&nbsp;&#9474;&nbsp;D&nbsp;&there4;&nbsp;(Ag &sup; B<u>g</u>)&nbsp;&nbsp;{from 6}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&#9474;&nbsp;D&nbsp;&there4;&nbsp;&sim;Ag&nbsp;&nbsp;{from 5 and 7}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&#9492;&nbsp;&there4;&nbsp;&sim;Ag&nbsp;&nbsp;{from 8 by indicative transfer rule}&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&there4;&nbsp;OB<u>g</u>&nbsp;&nbsp;{from 3; 2 contradicts 9}&nbsp;&nbsp;</td></tr></table></center><br>
	
We begin by assuming the opposite of the conclusion (line 3). We use the reverse-squiggle rules on 3 to get 4, drop "R" in 4 using a new deontic world "D" to get 5, and drop "O" in 1 using the old deontic world "D" to get 6. We derive lines 7 and 8 using quantificational and propositional rules. We apply the indicative transfer rule on 8 to get line 9. Finally, we apply RAA to complete the proof (line 10).<br>

<br><A name="N"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set N - Belief Translations</font></center><br>

<center><font size = "5">Believing</font></center><br>

<b>Belief logic</b> is "logic" in an extended sense. Instead of studying what follows from what, belief logic studies patterns of consistent believing and willing; it generates consistency norms that prescribe that we be consistent in various ways. We'll give a simplified system here; the book also gives a more sophisticated system with refinements and qualifications.<br><br>
Belief logic builds on our previous systems. It adds the symbol ":" and two additional ways to form wffs:
<ol>
<li>The result of writing a small letter and then ":" and then a wff is a descriptive wff;
<li>The result of writing an underlined small letter and then ":" and then a wff is an imperative wff.
</ol>
Here are some descriptive belief formulas:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">u:A</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You believe that A is true.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;&sim;u:A</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You don't believe that A is true.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;u:&sim;A</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You believe that A is false.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(&sim;u:A &#8226; &sim;u:&sim;A)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You take no position on A.</td></tr><tr><td nowrap>
<div align="right">(u:A &sup; &sim;u:B)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
If you believe A, then you don't believe B.&nbsp;&nbsp;</td></tr></table></center><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">u:OA<u>u</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You believe that you ought to do A.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;u:(x)OA<u>x</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You believe that everyone ought to do A.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(x)x:OA<u>u</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Everyone believes that you ought to do A.&nbsp;&nbsp;</td></tr></table></center><br>

Here are corresponding imperative belief formulas:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right"><u>u</u>:A</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Believe that A is true.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;&sim;<u>u</u>:A</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Don't believe that A is true.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;<u>u</u>:&sim;A</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Believe that A is false.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(&sim;<u>u</u>:A &#8226; &sim;<u>u</u>:&sim;A)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Take no position on A.</td></tr><tr><td nowrap>
<div align="right">(u:A &sup; &sim;<u>u</u>:B)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
If you believe A, then don't believe B.&nbsp;&nbsp;</td></tr></table></center><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right"><u>u</u>:OA<u>u</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Believe that you ought to do A.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;<u>u</u>:(x)OA<u>x</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Believe that everyone ought to do A.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;(x)<u>x</u>:OA<u>u</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Let everyone believe that you ought to do A.&nbsp;&nbsp;</td></tr></table></center><br>

As before, we distinguish between if-then and don't-combine forms:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;(u:A &sup; &sim;<u>u</u>:B)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
If you (in fact) believe A, then don't believe B.&nbsp;&nbsp;</td></tr><tr><td nowrap>
<div align="right">&sim;(<u>u</u>:A &#8226; <u>u</u>:B)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
Don't combine believing A with believing B.</td></tr></table></center><br>

<center><font size = "5">Willing</font></center><br>

We will treat <b>willing</b> as accepting-an-imperative (just as we previously treated <b>believing</b> as accepting-an-indicative):<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;u:<u>A</u></div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You accept (endorse, assent to) "Let A be done."&nbsp;&nbsp;<br>You will that A be done.</td></tr></table></center><br>

In translating "u:A," we'll often use terms more specific than "wills." We'll use words like "acts," "resolves," or "desires." Which of these fits depends on whether the imperative is present or future &ndash; and whether it applies to oneself or to another. Here are three examples:
<ul>
<li><b>If A is present:</b>&nbsp;&nbsp;u:A<u>u</u>&nbsp;&nbsp;=&nbsp;&nbsp;You accept the imperative for you to do A now&nbsp;&nbsp;=&nbsp;&nbsp;You act (in order) to do A.
<li><b>If A is future:</b>&nbsp;&nbsp;u:A<u>u</u>&nbsp;&nbsp;=&nbsp;&nbsp;You accept the imperative for you to do A in the future&nbsp;&nbsp;=&nbsp;&nbsp;You're resolved to do A.
<li><b>If u&ne;x:</b>&nbsp;&nbsp;u:A<u>x</u>&nbsp;&nbsp;=&nbsp;&nbsp;You accept the imperative for X to do A&nbsp;&nbsp;=&nbsp;&nbsp;You desire that X do A&nbsp;&nbsp;=&nbsp;&nbsp;You want X to do A.
</ul>
"You act (in order) to do A" ("u:A<u>u</u>") is about what you try or intend to do, while "You do A" ("Au") is about what you actually do (perhaps accidentally).<br><br>
These three are importantly different:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">u:(&exist;x)(Kx &#8226; R<u>x</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You desire that some who kill repent.</td></tr><tr><td nowrap>
<div align="right">u:(&exist;x)(K<u>x</u> &#8226; Rx)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You desire that some kill who repent.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;u:(&exist;x)(K<u>x</u> &#8226; R<u>x</u>)</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
You desire that some both kill and repent.&nbsp;&nbsp;</td></tr></table></center><br>

Underlining shows the desired parts (repenting, or killing, or killing-and-repenting) &ndash; and what imperative you are endorsing:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
Would that some who kill repent.<br>
Would that some kill who repent.<br>
&nbsp;&nbsp;Would that some both kill and repent.&nbsp;&nbsp;</center></td></tr></table></center><br>

If we just attached "desire" to indicative formulas, all would translate the same &ndash; as "You desire it to be the case that there is someone who both kills and repents."<br><br>
These imperative formulas tell someone to will something:
<ul>
<li><b>If A is present:</b>&nbsp;&nbsp;<u>u</u>:A<u>u</u>&nbsp;&nbsp;=&nbsp;&nbsp;Accept the imperative for you to do A now&nbsp;&nbsp;=&nbsp;&nbsp;Act (in order) to do A.
<li><b>If A is future:</b>&nbsp;&nbsp;<u>u</u>:A<u>u</u>&nbsp;&nbsp;=&nbsp;&nbsp;Accept the imperative for you to do A in the future&nbsp;&nbsp;=&nbsp;&nbsp;Be resolved to do A.
<li><b>If u&ne;x:</b>&nbsp;&nbsp;<u>u</u>:A<u>x</u>&nbsp;&nbsp;=&nbsp;&nbsp;Accept the imperative for X to do A&nbsp;&nbsp;=&nbsp;&nbsp;Desire that X do A&nbsp;&nbsp;=&nbsp;&nbsp;Want X to do A.
</ul>

Underlining can be confusing. This chart shows the basic cases:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
Indicatives</center><br>
&nbsp;&nbsp;u:A&nbsp;&nbsp;=&nbsp;&nbsp;You believe A.&nbsp;&nbsp;<br>
&nbsp;&nbsp;u:<u>A</u>&nbsp;&nbsp;=&nbsp;&nbsp;You will A.</td><td nowrap><center>
Imperatives</center><br>
&nbsp;&nbsp;<u>u</u>:A&nbsp;&nbsp;=&nbsp;&nbsp;Believe A.&nbsp;&nbsp;<br>
&nbsp;&nbsp;<u>u</u>:<u>A</u>&nbsp;&nbsp;=&nbsp;&nbsp;Will A.</td></tr></table></center><br>

Underlining before ":" makes the formula an imperative (instead of an indicative). Underlining after ":" makes the formula about willing (instead of believing).<br><br>
As before, we distinguish if-then from don't-combine forms:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
(u:O&sim;A<u>u</u> &sup; &sim;A<u>u</u>)<br>=<br>
If you believe that it's wrong for<br>you to do A, then don't do A.</center></td></tr><tr><td nowrap><center>
&sim;(<u>u</u>:O&sim;A<u>u</u> &#8226; <u>u</u>:A<u>u</u>)<br>=<br>
&nbsp;&nbsp;Don't combine believing that it's wrong for&nbsp;&nbsp;<br>you to do A with acting to do A.</center></td></tr></table></center><br>

The don't-combine form is provable.<br><br>

<center><font size = "5">Rationality</font></center><br>

Beliefs can be <b>evident</b> or <b>reasonable</b> for a given person. As I shade my eyes from the bright sun, my belief that it's sunny is evident; it's very solidly grounded. As I hear the prediction of rain, my belief that it will rain is reasonable; my belief accords with reason but isn't solid enough to be evident. "Evident" expresses a higher certitude than does "reasonable." We'll symbolize these two notions as follows:<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
<div align="right">&nbsp;&nbsp;O<u>u</u>:A</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
A is evident to you.<br>
It's obligatory (rationally required) that you believe A.&nbsp;&nbsp;<br>
Insofar as intellectual considerations are concerned,<br>
&nbsp;&nbsp;you ought to believe A.</td></tr><tr><td nowrap>
<div align="right">&nbsp;&nbsp;R<u>u</u>:A</div></td><td nowrap>&nbsp;&nbsp;=&nbsp;&nbsp;</td><td nowrap>
A would be reasonable for you to believe.<br>
It's all right (rationally permissible) that you believe A.&nbsp;&nbsp;<br>
Insofar as intellectual considerations are concerned,<br>
&nbsp;&nbsp;it would be all right for you to believe A.</td></tr></table></center><br>

Neither entails that you believe A. To claim that a proposition A that you believe is evident or reasonable, we'll use "(u:A&nbsp;&#8226;&nbsp;O<u>u</u>:A)" or "(u:A&nbsp;&#8226;&nbsp;R<u>u</u>:A)."<br><br>

"Evident" and "reasonable" are relational. "It's raining" might be evident to a person outside, but not to someone inside, since the two people might have different experiences. When I say a belief is evident or reasonable, but don't say to whom, assume that I mean <i>to you</i>.<br><br>
We again distinguish if-then from don't-combine forms:<br><br>

<center><table border="2" bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
(u:O&sim;A<u>u</u> &sup; O&sim;A<u>u</u>)<br>=<br>
If you believe that it's wrong for you to<br>do A, then you ought not to do A.</center></td></tr><tr><td nowrap><center>
O&sim;(<u>u</u>:O&sim;A<u>u</u> &#8226; <u>u</u>:A<u>u</u>)<br>=<br>
&nbsp;&nbsp;You ought not to combine believing that it's&nbsp;&nbsp;<br>wrong for you to do A with acting to do A.</center></td></tr></table></center><br>

Both of these are <b>formal ethical principles</b> &ndash; ethical principles that can be formulated using the abstract notions of our logical systems plus variables. The don't-combine form is provable in our system, while the if-then form leads to absurdities (see the book).<br>

<br><A name="O"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set O - Belief Proofs</font></center><br>

<center><font size = "5">Belief Arguments</font></center><br>
<b>Belief logic</b>, as we develop it here, studies consistency imperatives and duties. It assumes that we ought to be consistent (a principle that's subject to some implicit qualifications) and generates <b>consistency norms</b> like these three:<br><br>

<center><table border="2" rules=all bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>
&sim;(<u>u</u>:A &#8226; <u>u</u>:&sim;A)<br>
Don't combine believing A
<br>with believing not-A.</center></td></tr>
<tr><td nowrap><center>
&sim;(<u>u</u>:(A &#8226; B) &#8226; &sim;<u>u</u>:A)<br>
&nbsp;&nbsp;Don't combine believing A-and-B&nbsp;&nbsp;<br>
with not believing A.</center></td></tr></table></center><br>

All three are provable in belief logic. We'll take an argument to be "valid in belief logic" if it's valid presuming an implicit "We ought to be consistent" premise, which is built into the inference rules.<br><br>
Belief proofs require that we broaden our notions of world prefixes and possible worlds:
<ul>
<li>A <b>world prefix</b> is now a string of zero or more instances of letters from "W," "D," and the set of small letters. Here "u," "uu," "uuu," ... represent u's belief worlds.
<li>Suppose that we have a set of imperatives telling you what to believe or refrain from believing. A <b>belief world</b>, relative to these imperatives, is a possible world that contains everything that you're told to believe.
</ul>
If you're told to believe A, then <i>all</i> your belief worlds have A. Now individual belief worlds may contain further statements. For example, if you're told to be neutral about A (to refrain from believing A and to refrain from believing not-A), then some of your belief worlds will have A and some will have not-A. And if you're told to refrain from believing A, then some of your belief worlds will have not-A. What is common to all of your belief worlds is what you're positively told to believe.<br><br>
Belief logic adds two inference rules, called "B&minus;" and "B+"; in these, any pair of contradictory wffs can replace "A" / "&sim;A" and any small letter constant can replace "x":<br><br>

<center><table border="2" rules=rows bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;B&minus;&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;&sim;<u>u</u>:A&nbsp;&nbsp;&#8658;&nbsp;&nbsp;u &there4; &sim;A,&nbsp;&nbsp;<br>&nbsp;&nbsp;use a <b>new</b> string of u's&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;B+&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;<u>u</u>:A&nbsp;&nbsp;&#8658;&nbsp;&nbsp;u &there4; A,&nbsp;&nbsp;<br>&nbsp;&nbsp;use any string of u's&nbsp;&nbsp;</center></td></tr>
</table></center><br>

For both rules, the original line can use any world prefix not containing small letters or "W" &ndash; and the derived line must use a world prefix that is the same except that it adds a string of one or more u's at the end; in the B&minus; rule, in addition, the string of u's at the end must be new (one what hasn't occurred in earlier lines).<br><br>
B&minus; and B+ apply only to imperative belief formulas; our belief logic generates consistency imperatives (imperatives that tell us to be consistent in certain ways). We can do little with an indicative belief formula, like "u:A." Our belief worlds are about what you are told to believe &ndash; not about what you actually believe.<br><br>
The general strategy is to try to use B&minus; first, using it to introduce a new belief world each time, and to use B+ later, using the old belief worlds that you've already introduced. Star the original line when you use B&minus;, but not when you use B+. In some cases, you may have to drop B+ using a new belief world; but try to put this off as long as you can.<br><br>

Here's a belief proof (here the formula tells us not to combine believing A and believing not-A):<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;&sim;(<u>u</u>:A &#8226; <u>u</u>:&sim;A)&nbsp;&nbsp;&nbsp;&nbsp;Valid<br>
&nbsp;&nbsp;*&nbsp;&nbsp;1&nbsp;&#9484;&nbsp;asm: (<u>u</u>:A &#8226; <u>u</u>:&sim;A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&#9474;&nbsp;&there4;&nbsp;<u>u</u>:A</u>&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&#9474;&nbsp;&there4;&nbsp;<u>u</u>:&sim;A&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;u&nbsp;&there4;&nbsp;A&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9492;&nbsp;u&nbsp;&there4;&nbsp;&sim;A&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&there4;&nbsp;&sim;(<u>u</u>:A &#8226; <u>u</u>:&sim;A)&nbsp;&nbsp;{from 1; 4 contradicts 5}&nbsp;&nbsp;</td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 1). We simplify this to get 2 and 3. Since we don't have any negative belief formulas, we use B+ on the positive belief formula in 2, using a new belief world "u" to get 4. We apply B+ on 3 to get 4. Finally, we apply RAA to complete the proof (line 7).<br><br>

<center><font size = "5">Rationality Arguments</font></center><br>

Rationality proofs follow the same rules and work much the same. However, since we start with formulas like "Ou:A" in which a belief imperative occurs after a deontic operator, we typically end up with complicated belief worlds &ndash; like "Du" (which is a belief world of person u relative to a deontic world D); intuitively, this represents a belief world relative to what is permissible to believe in that deontic world.<br><br>
We distinguish weak operators from strong operators:<br><br>

<center><table border="2" rules=cols bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap><center>&nbsp;&nbsp;Weak operators:&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;Strong operators:&nbsp;&nbsp;</center></td></tr>
<tr><td nowrap><center>&nbsp;&nbsp;&sim;u:&nbsp;&nbsp;R&nbsp;&nbsp;&#9674;&nbsp;&nbsp;(&exist;x)&nbsp;&nbsp;</center></td>
<td nowrap><center>&nbsp;&nbsp;u:&nbsp;&nbsp;O&nbsp;&nbsp;&#9744;&nbsp;&nbsp;(x)&nbsp;&nbsp;</center></td></tr>
</table></center><br>

In dropping operators, try to drop the weak operators first &ndash; using a new world or constant &ndash; and starring the original line. Then try to drop these strong operators &ndash; using old worlds or constants if you have them &ndash; but not starring the original line. Drop "u:" and "O" before dropping the very strong "&#9744;."<br><br>
Here's a rationality proof (here the formula says that you ought not to combine (1) believing that you ought not to do A with (2) acting to do A):<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88><tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&thinsp;[&there4;&nbsp;O&sim;(<u>u</u>:O&sim;A<u>u</u> &#8226; <u>u</u>:A<u>u</u>)&nbsp;&nbsp;&nbsp;&nbsp;Valid<br>
&nbsp;&nbsp;*&nbsp;&nbsp;1&nbsp;&#9484;&nbsp;asm: &sim;O&sim;(<u>u</u>:O&sim;A<u>u</u> &#8226; <u>u</u>:A<u>u</u>)<br>
&nbsp;&nbsp;*&nbsp;&nbsp;2&nbsp;&#9474;&nbsp;&there4;&nbsp;R(<u>u</u>:O&sim;A<u>u</u> &#8226; <u>u</u>:A<u>u</u>)&nbsp;&nbsp;{from 1}<br>
&nbsp;&nbsp;*&nbsp;&nbsp;3&nbsp;&#9474;&nbsp;D&nbsp;&there4;&nbsp;(<u>u</u>:O&sim;A<u>u</u> &#8226; <u>u</u>:A<u>u</u>)&nbsp;&nbsp;{from 2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&#9474;&nbsp;D&nbsp;&there4;&nbsp;<u>u</u>:O&sim;A<u>u</u>&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&#9474;&nbsp;D&nbsp;&there4;&nbsp;<u>u</u>:A<u>u</u>&nbsp;&nbsp;{from 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&#9474;&nbsp;Du&nbsp;&there4;&nbsp;O&sim;A<u>u</u>&nbsp;&nbsp;{from 4}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&#9474;&nbsp;Du&nbsp;&there4;&nbsp;A<u>u</u>&nbsp;&nbsp;{from 5}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&#9492;&nbsp;Du&nbsp;&there4;&nbsp;&sim;A<u>u</u>&nbsp;&nbsp;{from 6}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&there4;&nbsp;O&sim;(<u>u</u>:O&sim;A<u>u</u> &#8226; <u>u</u>:A<u>u</u>)&nbsp;&nbsp;{from 1; 7 contradicts 8}&nbsp;&nbsp;</td></tr></table></center><br>

We begin by assuming the opposite of the conclusion (line 1). We reverse squiggles to get 2. We drop "R" in 2 using a new deontic world "D" to get 3. We simplify 3 to get 4 and 5. Since we don't have any negative belief formulas, we use B+ on the positive belief formula in 4, using a new belief world "Du" to get 6. We apply B+ on 5 to get 7. We drop the "O" from 6 to get 8. Finally, we apply RAA to complete the proof (line 9).<br>

<br><A name="P"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set P - Probability</font></center><br><br>

Click <A HREF="#dd"><b>dice</b></a> or <A HREF="#cc"><b>cards</b></a> if you'd like to review the rules assumed about these (which aren't universal across all cultures).<p>

<center><font size = "5">Percent</font></center><br>

This rule holds if each case is equally likely:
<ul>
<li>The <b>probability of A</b> = (the number of favorable cases) / (the total number of cases)
</ul>
So the probability of picking an ace randomly out of a normal deck of 52 cards = 4/52 = 1/13 = about 7.7%.<br><br>

<center><font size = "5">Odds</font></center><br>

Odds express probability as a ratio between favorable and unfavorable cases. The following rules presume that each case is equally likely.
<ul>
<li>The <b>odds are against you</b> if there are more unfavorable cases than favorable ones. Then the <b>odds against A</b> = (the number of unfavorable cases) / (the number of favorable cases). So the odds against picking an ace randomly out of a normal deck of 52 cards = 48/4 = 12/1 = 12 to 1.
<li>The <b>odds are even</b> if the number of favorable cases equals the number of unfavorable cases. So the odds of picking a heart or diamond randomly out of a normal deck of 52 cards are even (since 26=26).
<li>The <b>odds are in your favor</b> if there are more favorable cases than unfavorable ones. Then the <b>odds in favor of A</b> = (the number of favorable cases) / (the number of unfavorable cases). So the odds of picking a non-face card randomly out of a normal deck of 52 cards = 40/12 = 10/3 = 10 to 3 = 3.33 to 1.
</ul>

<center><font size = "5">Complex</font></center><br>

Here are three simple rules for calculating probability:
<ul>
<li><b>The probability of a necessary truth</b> = 100%. So the probability that it will either rain or not rain = 100%.
<li><b>The probability of a self-contradiction</b> = 0%. So the probability that it will both rain and not rain = 0%.
<li><b>The probability of not-A</b> = (100% - the percent probability of A). So if there's a 40% chance of having rain then there's a 60% chance of not having rain.
</ul>
Here are two rules for calculating <b>the probability of (A and B)</b>:
<ul>
<li>If A and B are independent events (the occurrence of one doesn't make the occurrence of the other any more or less likely), then the probability of (A and B) = (the probability of A) &#8226; (the probability of B). So if the probability of the first coin landing heads is 50% and the probability of the second coin landing heads is 50% then the probability of both coin landing heads = 50% &#8226; 50% = 25%.
<li>If A and B aren't independent events, then the probability of (A and then B) = (the probability of A) &#8226; (the probability of B after A occurs). So the probability of drawing a pair of aces when you draw two cards randomly from a normal deck of 52 cards = (4/52) &#8226; (3/51) = about 7.7% &#8226; 5.9% = about 0.45%.
</ul>
Here are two rules for calculating <b>the probability of (A or B)</b>:
<ul>
<li>If A and B are mutually exclusive events (they can't both happen together) then the probability of (A or B) = (the probability of A) + (the probability of B). So if the probability of picking an ace is 7.7% and the probability of instead picking a king is 7.7% then the probability of picking an ace or king = 7.7% + 7.7% = 15.4%.
<li>If A and B aren't mutually exclusive, then the probability of (A or B) = (the probability of A) + (the probability of B) - (the probability of (A and B)). So the probability of getting at least one head when flipping two coins = (the probability of getting the first head) + (the probability of getting the second head) - (the probability of getting both heads) = 50% + 50% - 25% = 75%.
</ul>
Here is how to convert from <b>odds to probability</b>:
<ul>
<li>If the odds in favor of A are x to y, then the probability of A = x / (x+y). So if the odds are 3 to 2 in favor of Michigan winning, then the probability of Michigan winning = 3 / (3+2) = 3/5 = 60%.
<li>If the odds are even (1 to 1) that A will happen, then the probability of A = 50%.
<li>If the odds against A are x to y, then the probability of A = y / (x+y). So if the odds are 9 to 1 against Ohio State winning, then the probability of Ohio State winning = 1 / (9+1) = 1/10 = 10%.
</ul>
<center><font size = "5">Gamble</font></center><br>

<b>The expected gain of betting on A</b> = (the probability of A happening &#8226; the money you get if A happens) - (the probability of A not happening &#8226; the money you lose if A doesn't happen).<br><br>
Suppose that you bet $10 that you'll draw an ace randomly out of a normal deck of 52 cards; you'll get $150 if you win and forfeit your $10 if you lose. The expected gain of this bet is ($150 &#8226; 4/52) - ($10 &#8226; 48/52) = $11.54 - $9.23 = $2.31. While you'd probably lose money if you bet this way just once, you'd likely win about $231 if you bet this way 100 times.<br><br>

<center><font size = "5">Decide</font></center><br>

In terms of expected gain, <b>decision A is better than B</b> if the expected gain of A is greater than the expected gain of B. My travel agent once gave me two alternatives:
<ul>
<li>Ticket A costs $250 and allows me to change my return date.
<li>Ticket B costs $200 but has a $125 charge if I have to change my return.
</ul>
Let's suppose that there's a 20% probability that I'll have to change my return. Then the expected cost of A is $250 (since that's what it is regardless of what happens) while the expected cost of B = $200 + ($125 &#8226; 20%) = $200 + $25 = $225. So, in terms of expected gain, ticket B is the better deal.<br><br>
In some cases, however, it might be more rational to pick A. Maybe I have $250 but I don't have the $325 that option B might cost me &ndash; so I'd be in great trouble if I had to change the return date. It might then be more rational to follow the "better safe than sorry" principle and pick A.<br><br>

<center><font size = "5">Induction</font></center><br>

<b>Inductive reasoning</b> generalizes on our experience and leads at best to a probable conclusion. The <b>statistical syllogism</b>, a common form of inductive reasoning, goes as follows:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N percent of A's are B's.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X is an A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is all we know about the matter.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; It's N percent probable that X is a B.</td></tr></table></center><br>

Suppose that 90% of the Appalachian Trail shelters have water, Rocky Gap Shelter is an Appalachian Trail shelter, and this is all we know about the matter. Then we could conclude that it's 90% probable that Rocky Gap Shelter has water.<br><br>
The <b>sample-projection syllogism</b> goes as follows:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N percent of examined A's are B's.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A large and varied group of A's has been examined.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; Probably roughly N percent of all A's are B's.</td></tr></table></center><br>

Suppose that 90% of all examined cats purr &ndash; and a large and varied group of cats has been examined. Then we could conclude that probably roughly 90 percent of all cats purr.<br><br>
The <b>analogy syllogism</b> goes as follows:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Most of the things true of X are also true of Y.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X is A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is all we know about the matter.<br>
&nbsp;&nbsp;&there4; Probably Y is A.</td></tr></table></center><br>

Suppose that most of the things true of the first casino we visit are also true of the second casino we visit. The first casino has an all-you-can-eat buffet. This is all we know about the matter. Then we could reasonably suppose that the second casino probably also has an all-you-can-eat buffet.<br><br>

<center><font size = "5">Mill</font></center><br>

<b>Mill's methods</b> are rough rules for arriving at and justifying claims about causes. The basic insight behind them is that factors occurring together in some regular way are likely to be causally related. We'll consider four of his methods.<br><br>
The <b>method of agreement</b> reasons as follows:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A occured more than once.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B is the only additional factor that<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; occured if and only if A occured.<br>
&nbsp;&nbsp;&there4; Probably B caused A, or A caused B.&nbsp;&nbsp;</td></tr></table></center><br>

Suppose that there are several cases of sickness. The eating of Judy's pie is the only additional factor that occurs if and only if the sickness occurs. Then we could conclude that probably eating her pie caused people to get sick, or getting sick caused them to eat her pie.<br><br>
The <b>method of disagreement</b> reasons as follows:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A occurred in some case.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B didn't occur in the same case.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&there4; A doesn't necessarily cause B.</td></tr></table></center><br>

Suppose that I ate Judy's pie but didn't get sick. Then we can conclude that eating her pie doesn't necessarily cause sickness.<br><br>
The <b>method of difference</b> reasons as follows:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A occurred in the first case but not the second.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The cases are otherwise identical, except that B also&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; occurred in the first case but not in the second.<br>
&nbsp;&nbsp;&there4; Probably B is (or is part of) the cause of A, or A is (or&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is part of) the cause of B.</td></tr></table></center><br>

Suppose that X got sick but Y didn't. The cases are otherwise identical, except that X ate Judy's pie but Y didn't. Then we can conclude that probably X's eating her pie is (or is part of) the cause of his sickness, or X's sickness is (or is part of) the cause of his eating the pie.<br><br>
The <b>method of variation</b> reasons as follows:<br><br>

<center><table border="2" rules=none bordercolor=#000000 bgcolor=#FFFF88>
<tr><td nowrap>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;A changes in a certain way if and only if B&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; also changes in a certain way.<br>
&nbsp;&nbsp;&there4; Probably B caused A, or A caused B, or<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; some C caused both A and B.</td></tr></table></center><br>

Suppose that how sick people got correlated with how much of Judy's pie they ate. Then we can conclude that probably eating her pie caused the sickness, or the sickness caused them to eat her pie, or something else caused both the eating and the sickness.<br><br>

<A name="dd"><center><font size = "5">Dice</font></center><br>

<b>Dice</b> are six-sided cubes, often made from plastic or wood, used in games of chance. Each side has a number of dots from 1 to 6 (so rolling the cube will randomly give you a number from 1 to 6):<p>

<center><table border="2" cellpadding="2" cellspacing="0" bordercolor=#000000 bgcolor=#FFFF88>
<tr>

<td align="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</td>

<td align="center">
&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;
</td>

<td align="center">
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;
</td>

<td align="center">
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;
</td>

<td align="center">
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;
</td>

<td align="center">
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<br>
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<br>
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;
</td>
</table></center><br>

Judy and you might each roll a single die ("die" is singular, "dice" is plural); the person with the higher number on top wins. Suppose Judy rolls a 2:<p>

<center><table border="2" cellpadding="2" cellspacing="0" bordercolor=#000000 bgcolor=#FFFF88>
<tr>
<td align="center">
&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;
</td>
</table></center><br>

You beat Judy if you roll a 3, 4, 5, or 6; so you have a 4 in 6 (66.7%) chance of beating Judy. You tie if you roll a 2; so you have a 1 in 6 (16.7%) chance of tying. You lose if you roll a 1; so you have a 1 in 6 (16.7%) chance of losing. So your chance of tying is the same as your chance of losing.<p>

Often people roll two dice, and get a score that equals both numbers added together. Suppose Judy rolls a 7 (4+3):<p>

<center><table border="2" cellpadding="2" cellspacing="0" bordercolor=#000000 bgcolor=#FFFF88>
<tr>

<td align="center">
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;
</td>

<td align="center">
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;
</td>
</table></center><br>

You beat Judy if you get an 8 or above, which you can get 15 ways (6+2, 6+3, 6+4, 6+5, 6+6, 5+3, 5+4, 5+5, 5+6, 4+4, 4+5, 4+6, 3+5, 3+6, 2+6); so you have a 15 in 36 (41.7%) chance of beating Judy. You tie if you get exactly 7, which you can get in 6 ways (6+1, 5+2, 4+3, 3+4, 2+5, 1+6); so you have a 6 in 36 (16.7%) chance of tying. You lose if you get 6 or below, which you can get in 15 ways (5+1, 4+2, 4+1, 3+3, 3+2, 3+1, 2+4, 2+3, 2+2, 2+1, 1+5, 1+4, 1+3, 1+2, 1+1); so you have a 15 in 36 (41.7%) chance of losing. So your chance of winning is the same as your chance of losing.<br><br>

<A name="cc"><center><font size = "5">Cards</font></center><br>

<b>Playing cards</b> are rectangles, often made of plastic-covered paper, used in playing <b>card games</b> that typically combine chance and strategy. In the system assumed here, cards have one of 13 <b>values</b>. In ascending order, these <b>values</b> are 2, 3, 4, 5, 6, 7, 8, 9, 10, J (jack), Q (queen), K (king), and A (ace):<p>

<center><table border="1" cellpadding="1" cellspacing="0" bordercolor=#000000 bgcolor=#FFFF88>
<tr>
<td align="center">&nbsp<br>&nbsp;&nbsp;&nbsp;lower&nbsp;&nbsp;&nbsp;<br>&nbsp</td>
<td align="center">&nbsp<br>&nbsp;&nbsp;&nbsp;2 3 4 5 6 7 8 9 10 J Q K A&nbsp;&nbsp;&nbsp;<br>&nbsp</td>
<td align="center">&nbsp<br>&nbsp;&nbsp;&nbsp;higher&nbsp;&nbsp;&nbsp;<br>&nbsp</td>
</tr>
</table></center><br>

Higher values beat lower ones  so a 9 beats a 3, a Q (queen) beats any card lower in the sequence, and an A (ace) beats any other card.<p>

A <b>standard deck</b> of cards has 52 cards, divided into 4 <b>suits</b> (hearts &hearts;, diamonds &diams;, clubs &clubs;, and spades &spades;). Each suit has one card for each of the 13 values. So the 52 cards in a standard deck look like this:<p>

<center><table border="1" cellpadding="1" cellspacing="0" bordercolor=#000000 bgcolor=#FFFF88>
<tr> <!-- hearts -->

<td align="center">
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;</td>

<td align="center">
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&hearts;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;</td>
</td>

<td align="center">
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;</td>

<td align="center">
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&hearts;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;</td>

<td align="center">
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&hearts;&nbsp;&nbsp;&hearts;<br>
&hearts;&hearts;<br>
&hearts;&nbsp;&nbsp;&hearts;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;</td>

<td align="center">
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&hearts;&nbsp;&hearts;<br>
&hearts;&hearts;&hearts;<br>
&hearts;&nbsp;&hearts;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;</td>
</td>

<td align="center">
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&hearts;&nbsp;&nbsp;&hearts;<br>
&hearts;&hearts;&hearts;&hearts;<br>
&hearts;&nbsp;&nbsp;&hearts;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;</td>

<td align="center">
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&hearts;&hearts;&hearts;<br>
&hearts;&hearts;&hearts;<br>
&hearts;&hearts;&hearts;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;</td>
</td>

<td align="center">
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&hearts;&hearts;&hearts;&hearts;<br>
&hearts;&nbsp;&nbsp;&hearts;<br>
&hearts;&hearts;&hearts;&hearts;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;</td>
</td>

<td align="center">
&nbsp;J&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J&nbsp;</td>

<td align="center">
&nbsp;Q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;</td>

<td align="center">
&nbsp;K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K&nbsp;</td>

<td align="center">
&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;<br>
&hearts;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;</td>

</tr><tr> <!-- diamonds -->

<td align="center">
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&diams;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&diams;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;</td>

<td align="center">
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&diams;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&diams;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&diams;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;</td>
</td>

<td align="center">
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&diams;&nbsp;&nbsp;&nbsp;&nbsp;&diams;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&diams;&nbsp;&nbsp;&nbsp;&nbsp;&diams;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;</td>

<td align="center">
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&diams;&nbsp;&nbsp;&nbsp;&nbsp;&diams;&nbsp;<br>
&diams;<br>
&nbsp;&diams;&nbsp;&nbsp;&nbsp;&nbsp;&diams;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;</td>

<td align="center">
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&diams;&nbsp;&nbsp;&diams;<br>
&diams;&diams;<br>
&diams;&nbsp;&nbsp;&diams;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;</td>

<td align="center">
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&diams;&nbsp;&diams;<br>
&diams;&diams;&diams;<br>
&diams;&nbsp;&diams;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;</td>
</td>

<td align="center">
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&diams;&nbsp;&nbsp;&diams;<br>
&diams;&diams;&diams;&diams;<br>
&diams;&nbsp;&nbsp;&diams;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;</td>

<td align="center">
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&diams;&diams;&diams;<br>
&diams;&diams;&diams;<br>
&diams;&diams;&diams;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;</td>
</td>

<td align="center">
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&diams;&diams;&diams;&diams;<br>
&diams;&nbsp;&nbsp;&diams;<br>
&diams;&diams;&diams;&diams;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;</td>
</td>

<td align="center">
&nbsp;J&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&diams;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&diams;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J&nbsp;</td>

<td align="center">
&nbsp;Q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&diams;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&diams;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;</td>

<td align="center">
&nbsp;K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&diams;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&diams;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K&nbsp;</td>

<td align="center">
&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;<br>
&diams;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;</td>

</tr><tr> <!-- clubs -->

<td align="center">
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&clubs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&clubs;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;</td>

<td align="center">
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&clubs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&clubs;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&clubs;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;</td>
</td>

<td align="center">
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&clubs;&nbsp;&nbsp;&nbsp;&nbsp;&clubs;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&clubs;&nbsp;&nbsp;&nbsp;&nbsp;&clubs;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;</td>

<td align="center">
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&clubs;&nbsp;&nbsp;&nbsp;&nbsp;&clubs;&nbsp;<br>
&clubs;<br>
&nbsp;&clubs;&nbsp;&nbsp;&nbsp;&nbsp;&clubs;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;</td>

<td align="center">
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&clubs;&nbsp;&nbsp;&clubs;<br>
&clubs;&clubs;<br>
&clubs;&nbsp;&nbsp;&clubs;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;</td>

<td align="center">
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&clubs;&nbsp;&clubs;<br>
&clubs;&clubs;&clubs;<br>
&clubs;&nbsp;&clubs;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;</td>
</td>

<td align="center">
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&clubs;&nbsp;&nbsp;&clubs;<br>
&clubs;&clubs;&clubs;&clubs;<br>
&clubs;&nbsp;&nbsp;&clubs;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;</td>

<td align="center">
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&clubs;&clubs;&clubs;<br>
&clubs;&clubs;&clubs;<br>
&clubs;&clubs;&clubs;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;</td>
</td>

<td align="center">
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&clubs;&clubs;&clubs;&clubs;<br>
&clubs;&nbsp;&nbsp;&clubs;<br>
&clubs;&clubs;&clubs;&clubs;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;</td>
</td>

<td align="center">
&nbsp;J&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&clubs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&clubs;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J&nbsp;</td>

<td align="center">
&nbsp;Q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&clubs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&clubs;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;</td>

<td align="center">
&nbsp;K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&clubs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&clubs;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K&nbsp;</td>

<td align="center">
&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;<br>
&clubs;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;</td>

</tr><tr> <!-- spades -->

<td align="center">
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&spades;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&spades;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;</td>

<td align="center">
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&spades;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&spades;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&spades;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;</td>
</td>

<td align="center">
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&spades;&nbsp;&nbsp;&nbsp;&nbsp;&spades;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&spades;&nbsp;&nbsp;&nbsp;&nbsp;&spades;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;</td>

<td align="center">
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&spades;&nbsp;&nbsp;&nbsp;&nbsp;&spades;&nbsp;<br>
&spades;<br>
&nbsp;&spades;&nbsp;&nbsp;&nbsp;&nbsp;&spades;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;</td>

<td align="center">
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&spades;&nbsp;&nbsp;&spades;<br>
&spades;&spades;<br>
&spades;&nbsp;&nbsp;&spades;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;</td>

<td align="center">
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&spades;&nbsp;&spades;<br>
&spades;&spades;&spades;<br>
&spades;&nbsp;&spades;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;</td>
</td>

<td align="center">
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&spades;&nbsp;&nbsp;&spades;<br>
&spades;&spades;&spades;&spades;<br>
&spades;&nbsp;&nbsp;&spades;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;</td>

<td align="center">
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&spades;&spades;&spades;<br>
&spades;&spades;&spades;<br>
&spades;&spades;&spades;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;</td>
</td>

<td align="center">
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&spades;&spades;&spades;&spades;<br>
&spades;&nbsp;&nbsp;&spades;<br>
&spades;&spades;&spades;&spades;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;</td>
</td>

<td align="center">
&nbsp;J&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&spades;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&spades;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J&nbsp;</td>

<td align="center">
&nbsp;Q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&spades;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&spades;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;</td>

<td align="center">
&nbsp;K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&spades;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&spades;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K&nbsp;</td>

<td align="center">
&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;<br>
&spades;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;</td>

</tr></table></center><br>

Every deck uses the same pattern or picture for the back of each card, so the back of the cards look the same. When the deck is shuffled (randomized) and all you see is the back of the cards, then picking a card gives you a random card.<p>

This chart represent a standard deck more compactly:<p>

<center><table border="1" cellpadding="1" cellspacing="0" bordercolor=#000000 bgcolor=#FFFF88>
<tr>

<td align="center">
hearts&nbsp;&nbsp;&hearts;<br>
&nbsp;&nbsp;&nbsp;diamonds&nbsp;&nbsp;&diams;&nbsp;&nbsp;&nbsp;<br>
clubs&nbsp;&nbsp;&clubs;<br>
spades&nbsp;&nbsp;&spades;</td>

<td align="center">
&nbsp;&nbsp;&nbsp;2 3 4 5 6 7 8 9 10 J Q K A&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;2 3 4 5 6 7 8 9 10 J Q K A&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;2 3 4 5 6 7 8 9 10 J Q K A&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;2 3 4 5 6 7 8 9 10 J Q K A&nbsp;&nbsp;&nbsp;
</td></tr>
</table></center><br>

Again, a standard deck has 52 cards: 4 suits x 13 values.<p> 

Judy and you might each pick a single card from a standard deck, which has been shuffled (randomized); the person with the higher card wins. Suppose Judy picks a 4 of hearts:<p>

<center><table border="1" cellpadding="1" cellspacing="0" bordercolor=#000000 bgcolor=#FFFF88>
<tr>
<td align="center">
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&hearts;&nbsp;&nbsp;&nbsp;&nbsp;&hearts;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;</td>
</td>
</table></center><br>

You beat Judy if you pick a 5 or above of any suit; since there are 40 such cards (10 of each suit) in the remaining 51 cards, you have a 40 in 51 (78.4%) chance of beating Judy. You tie if you pick a 4; since there are 3 such cards in the remaining 51 cards, you have a 3 in 51 (5.9%) chance of tying. You lose if you pick a 3 or below of any suit; since there are 8 such cards (2 of each suit), you have an 8 in 51 (15.6%) chance of losing.<p>

Suppose that Judy, after having just picked a 4 of hearts, wants to pick another 4. As just noted, since there are 3 such cards in the remaining 51 cards, she has a 3 in 51 (5.9%) chance of picking another 4. Or suppose that she instead wants to pick another heart; since there are 12 more hearts in the remaining 51 cards, she has a 12 in 51 (23.5%) chance of picking another heart. Or suppose that she instead wants to pick another 4 of hearts; since there are no more such cards in the remaining 51 cards, she has a 0 in 51 (0%) chance of picking another 4 of hearts.<p>

People sometimes play using a <b>double deck</b>, which puts two standard decks together and thus has 104 cards (26 for each suit). The probabilities change if we use a double deck. Suppose that Judy, after having just picked a 4 of hearts, wants to pick another 4 from a double deck. Since now there are 7 such cards in the remaining 103 cards, she has a 7 in 103 (6.8%) chance of picking another 4. Or suppose that she instead wants to pick another heart from the double deck; since there now are 25 more hearts in the remaining 103 cards, she has a 25 in 103 (24.3%) chance of picking another heart. Or suppose that she instead wants to pick another 4 of hearts from the double deck; since there now is one such card in the remaining 103 cards, she has a 1 in 103 (0.97%) chance of picking another 4 of hearts.<p>

<A name="Q"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set Q - Definitions</font></center><br>

A <b>definition</b> is a rule of paraphrase designed to explain meaning. More precisely, a definition of a word or phrase is a rule saying how to eliminate this word or phrase in any sentence using it and produce a second sentence that means the same thing &ndash; the purpose of this being to explain or clarify the meaning of the word or phrase.<br><br>
Definitions may be <b>stipulative</b> (specifying your own usage) or <b>lexical</b> (explaining current usage). A <b>good lexical definition</b> should allow us to "paraphrase out" a term &ndash; to produce a second sentence that means the same thing but doesn't use the defined term. A good lexical definition should:
<ul>
<li>be neither too broad nor too narrow,
<li>avoid circularity and poorly understood terms,
<li>match in vagueness the term defined,
<li>match, as far as possible, the emotional tone (positive or negative or neutral) of the term defined, and
<li>include only properties essential to the term.
</ul>
Here are examples of faulty definitions:
<ul>
<li>This is <b>too broad</b> (since there are men who aren't bachelors): "Bachelor" means "man."
<li>This is <b>too narrow</b> (since there are bachelors who aren't astronauts): "Bachelor" means "unmarried male astronaut."
<li>This is <b>circular</b> (since it defines "true" using "true"): "True" means "known to be true."
<li>This <b>uses poorly understood terms</b> (since "aretaic" is less clear than "good"): "Good" means "having positive aretaic value."
<li>This <b>has a poor match in vagueness</b> (since the defining expression is much more precise than "bachelor"): "Bachelor" means "unmarried male over 18 years old."
<li>This <b>has a poor match in emotional tone</b> (since the defining expression is laudatory): "Bachelor" means "fortunate man who hasn't married."
<li>This <b>includes non-essential properties</b> (since we could imagine a bachelor who lives on the moon): "Bachelor" means "unmarried man living on the earth."
</ul>

<A name="R"></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><div align="justify"><HR noshade size=1>
<center><font size="6">Set R - Fallacies</font></center><br>

A <b>fallacy</b> is a deceptive error of thinking; an <b>informal fallacy</b> is a deceptive error of thinking that isn't covered by some system of deductive or inductive logic. Here we'll study 18 informal fallacies, divided into four groups.<br><br>
Our first group of fallacies can be explained as defects in what is required for a good argument. A <b>good argument</b> (in the sense of a non-defective and pragmatically useful argument) should ideally:
<ul>
<li>be deductive valid (or inductively strong) and have all true premises;
<li>have its validity and truth-of-premises be as evident as possible to the parties involved;
<li>be clearly stated (using understandable language and making clear what the premises and conclusion are);
<li>avoid circularity, ambiguity, and emotional language; and
<li>be relevant to the issue at hand.
</ul>

This first group of fallacies violate the last two conditions:
<ul>
<li><b>Circular (question begging):</b> Presuming the truth of what is to be proved. Or: using a premise to prove a conclusion &ndash; and then using that conclusion to prove the premise.
<li><b>Ambiguous:</b> Changing the meaning of a term or phrase within the argument.
<li><b>Appeal to emotion:</b> Stirring up emotions instead of arguing in a logical manner.
<li><b>Beside the point:</b> Arguing for a conclusion irrelevant to the issue at hand. (This fallacy isn't just where the premises are irrelevant to the conclusion; instead, the conclusion is irrelevant.)
<li><b>Straw man:</b> Misrepresenting an opponent's views.
</ul>

This next group is conveniently expressed in a premise-conclusion format:
<ul>
<li><b>Appeal to the crowd:</b> Most people believe A; therefore, A is true.
<li><b>Appeal to ignorance:</b> No one has proved A; therefore, A is false. Or: no one has disproved A; therefore, A is true. (This fallacy isn't just where someone talks in ignorance.)
<li><b>Part-whole:</b> It is F; therefore, all its parts are F. Or: all its parts are F; therefore, it is F.
<li><b>Genetic fallacy:</b> We can explain why you believe A; therefore, A is false.
<li><b>Opposition:</b> Our opponents believe A; therefore, A is false.
<li><b>Post hoc ergo propter hoc (after this therefore because of this):</b> A happened after B; therefore, A was caused by B.
</ul>

This next group can be either correct or faulty reasoning:
<ul>
<li><b>Appeal to authority:</b> To be correct, there must be (1) an appeal to a genuine authority on the subject, (2) a consensus of such authorities, and (3) a conclusion that the belief is probably right (and not that it must be right).
<li><b>Ad hominem (personal attack):</b> To be correct, (1) the grounds of the attack must be relevant to the person's rational competence and (2) the conclusion must say that the person's belief isn't rationally held (and not that it's false).
<li><b>Pro-con:</b> To be correct, there must be (1) a fair appraisal of pros and cons, and (2) a premise that says that one of these outweighs the other.
</ul>

This last group has fallacies that don't fit in the previous groups:
<ul>
<li><b>Appeal to force:</b> Using threats or intimidation to get a conclusion accepted.
<li><b>Black and white thinking:</b> Oversimplifying by assuming that one or another of two extremes must be true.
<li><b>Complex question:</b> Asking a question that assumes the truth of something false or doubtful.
<li><b>False stereotype:</b> Assuming that members of a certain group are more alike than they are.
</ul>

I suggest that you go through the names of the various fallacies and try to explain in your own words what each fallacy involves. To do the fallacy exercises well, you need to (a) understand what each fallacy involves, (b) see what is wrong with the passage that you're dealing with, and (c) match what is wrong with the passage to one or more of the fallacies.<br>

<br></div><div align="right"><font size="2"><A HREF="#0">&#8593; return to top (or use HOME key) &#8593;</A></font></div><HR noshade size=1>
</body></html>